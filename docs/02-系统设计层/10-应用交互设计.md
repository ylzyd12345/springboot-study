# Junmo Platform åº”ç”¨äº¤äº’è®¾è®¡

## ğŸ“‹ æ–‡æ¡£ä¿¡æ¯

| é¡¹ç›® | å†…å®¹ |
|------|------|
| **æ–‡æ¡£åç§°** | Junmo Platform åº”ç”¨äº¤äº’è®¾è®¡ |
| **ç‰ˆæœ¬å·** | v1.0.0 |
| **åˆ›å»ºæ—¥æœŸ** | 2025-12-24 |
| **ä½œè€…** | å‰ç«¯æ¶æ„å¸ˆ |
| **å®¡æ ¸äºº** | UI/UXè®¾è®¡å¸ˆ |
| **æ‰¹å‡†äºº** | äº§å“ç»ç† |

## ğŸ¯ äº¤äº’æ¶æ„æ¦‚è¿°

Junmo Platformé‡‡ç”¨ç°ä»£åŒ–çš„å‰åç«¯åˆ†ç¦»æ¶æ„ï¼Œå‰ç«¯åŸºäºVue.js 3 + TypeScriptæ„å»ºï¼Œåç«¯æä¾›RESTful APIå’ŒWebSocketå®æ—¶é€šä¿¡ã€‚æ•´ä¸ªäº¤äº’è®¾è®¡éµå¾ªå“åº”å¼è®¾è®¡åŸåˆ™ï¼Œæ”¯æŒå¤šç«¯é€‚é…ï¼Œæä¾›æµç•…çš„ç”¨æˆ·ä½“éªŒã€‚

## ğŸ—ï¸ å‰ç«¯æ¶æ„è®¾è®¡

### 1. æŠ€æœ¯æ ˆé€‰æ‹©

**æ ¸å¿ƒæŠ€æœ¯æ ˆ**:
```json
{
  "framework": "Vue.js 3.3+",
  "language": "TypeScript 5.0+",
  "ui-library": "Element Plus 2.4+",
  "state-management": "Pinia 2.1+",
  "router": "Vue Router 4.2+",
  "http-client": "Axios 1.5+",
  "build-tool": "Vite 4.4+",
  "css-preprocessor": "Sass/SCSS",
  "testing": "Vitest + Vue Test Utils"
}
```

**é¡¹ç›®ç»“æ„**:
```
frontend/
â”œâ”€â”€ public/
â”‚   â”œâ”€â”€ favicon.ico
â”‚   â””â”€â”€ index.html
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ api/                    # APIæ¥å£
â”‚   â”‚   â”œâ”€â”€ auth.ts
â”‚   â”‚   â”œâ”€â”€ user.ts
â”‚   â”‚   â”œâ”€â”€ document.ts
â”‚   â”‚   â””â”€â”€ workflow.ts
â”‚   â”œâ”€â”€ assets/                 # é™æ€èµ„æº
â”‚   â”‚   â”œâ”€â”€ images/
â”‚   â”‚   â”œâ”€â”€ icons/
â”‚   â”‚   â””â”€â”€ styles/
â”‚   â”œâ”€â”€ components/             # é€šç”¨ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ common/
â”‚   â”‚   â”œâ”€â”€ form/
â”‚   â”‚   â”œâ”€â”€ table/
â”‚   â”‚   â””â”€â”€ layout/
â”‚   â”œâ”€â”€ composables/            # ç»„åˆå¼å‡½æ•°
â”‚   â”‚   â”œâ”€â”€ useAuth.ts
â”‚   â”‚   â”œâ”€â”€ useTable.ts
â”‚   â”‚   â””â”€â”€ useWebSocket.ts
â”‚   â”œâ”€â”€ layouts/                # å¸ƒå±€ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ DefaultLayout.vue
â”‚   â”‚   â”œâ”€â”€ AuthLayout.vue
â”‚   â”‚   â””â”€â”€ EmptyLayout.vue
â”‚   â”œâ”€â”€ pages/                  # é¡µé¢ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”œâ”€â”€ dashboard/
â”‚   â”‚   â”œâ”€â”€ users/
â”‚   â”‚   â”œâ”€â”€ documents/
â”‚   â”‚   â””â”€â”€ workflow/
â”‚   â”œâ”€â”€ router/                 # è·¯ç”±é…ç½®
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ guards.ts
â”‚   â”œâ”€â”€ stores/                 # çŠ¶æ€ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ auth.ts
â”‚   â”‚   â”œâ”€â”€ user.ts
â”‚   â”‚   â”œâ”€â”€ document.ts
â”‚   â”‚   â””â”€â”€ app.ts
â”‚   â”œâ”€â”€ types/                  # TypeScriptç±»å‹å®šä¹‰
â”‚   â”‚   â”œâ”€â”€ api.ts
â”‚   â”‚   â”œâ”€â”€ user.ts
â”‚   â”‚   â””â”€â”€ document.ts
â”‚   â”œâ”€â”€ utils/                  # å·¥å…·å‡½æ•°
â”‚   â”‚   â”œâ”€â”€ request.ts
â”‚   â”‚   â”œâ”€â”€ storage.ts
â”‚   â”‚   â””â”€â”€ validation.ts
â”‚   â”œâ”€â”€ App.vue
â”‚   â””â”€â”€ main.ts
â”œâ”€â”€ package.json
â”œâ”€â”€ vite.config.ts
â”œâ”€â”€ tsconfig.json
â””â”€â”€ tailwind.config.js
```

### 2. çŠ¶æ€ç®¡ç†æ¶æ„

**Pinia Storeè®¾è®¡**:

```typescript
// stores/auth.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import type { User, LoginCredentials } from '@/types/user'
import { authApi } from '@/api/auth'

export const useAuthStore = defineStore('auth', () => {
  // çŠ¶æ€
  const user = ref<User | null>(null)
  const token = ref<string>('')
  const refreshToken = ref<string>('')
  const permissions = ref<string[]>([])
  const isLoading = ref(false)

  // è®¡ç®—å±æ€§
  const isAuthenticated = computed(() => !!token.value && !!user.value)
  const hasPermission = computed(() => (permission: string) => 
    permissions.value.includes(permission) || 
    permissions.value.includes('*:*')
  )
  const userRoles = computed(() => user.value?.roles || [])

  // æ–¹æ³•
  const login = async (credentials: LoginCredentials) => {
    try {
      isLoading.value = true
      
      const response = await authApi.login(credentials)
      const { accessToken, refreshToken: refresh, user: userData, permissions: userPermissions } = response.data
      
      // ä¿å­˜åˆ°çŠ¶æ€
      token.value = accessToken
      refreshToken.value = refresh
      user.value = userData
      permissions.value = userPermissions
      
      // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
      localStorage.setItem('auth_token', accessToken)
      localStorage.setItem('refresh_token', refresh)
      
      return response
    } catch (error) {
      throw error
    } finally {
      isLoading.value = false
    }
  }

  const logout = async () => {
    try {
      if (token.value) {
        await authApi.logout()
      }
    } catch (error) {
      console.error('Logout error:', error)
    } finally {
      // æ¸…é™¤çŠ¶æ€
      user.value = null
      token.value = ''
      refreshToken.value = ''
      permissions.value = []
      
      // æ¸…é™¤æœ¬åœ°å­˜å‚¨
      localStorage.removeItem('auth_token')
      localStorage.removeItem('refresh_token')
      
      // é‡å®šå‘åˆ°ç™»å½•é¡µ
      router.push('/login')
    }
  }

  const refreshToken = async () => {
    try {
      const response = await authApi.refreshToken(refreshToken.value)
      const { accessToken } = response.data
      
      token.value = accessToken
      localStorage.setItem('auth_token', accessToken)
      
      return accessToken
    } catch (error) {
      // åˆ·æ–°å¤±è´¥ï¼Œæ‰§è¡Œç™»å‡º
      await logout()
      throw error
    }
  }

  const loadUserPermissions = async () => {
    if (!user.value) return
    
    try {
      const response = await authApi.getUserPermissions(user.value.id)
      permissions.value = response.data
    } catch (error) {
      console.error('Failed to load permissions:', error)
    }
  }

  return {
    // çŠ¶æ€
    user,
    token,
    refreshToken,
    permissions,
    isLoading,
    
    // è®¡ç®—å±æ€§
    isAuthenticated,
    hasPermission,
    userRoles,
    
    // æ–¹æ³•
    login,
    logout,
    refreshToken,
    loadUserPermissions
  }
})
```

### 3. è·¯ç”±å’Œæƒé™æ§åˆ¶

**è·¯ç”±é…ç½®**:

```typescript
// router/index.ts
import { createRouter, createWebHistory } from 'vue-router'
import type { RouteRecordRaw } from 'vue-router'
import { useAuthStore } from '@/stores/auth'

const routes: RouteRecordRaw[] = [
  {
    path: '/',
    redirect: '/dashboard'
  },
  {
    path: '/auth',
    component: () => import('@/layouts/AuthLayout.vue'),
    children: [
      {
        path: 'login',
        name: 'Login',
        component: () => import('@/pages/auth/Login.vue'),
        meta: {
          title: 'ç™»å½•',
          requiresAuth: false
        }
      },
      {
        path: 'register',
        name: 'Register',
        component: () => import('@/pages/auth/Register.vue'),
        meta: {
          title: 'æ³¨å†Œ',
          requiresAuth: false
        }
      }
    ]
  },
  {
    path: '/',
    component: () => import('@/layouts/DefaultLayout.vue'),
    meta: {
      requiresAuth: true
    },
    children: [
      {
        path: 'dashboard',
        name: 'Dashboard',
        component: () => import('@/pages/dashboard/Dashboard.vue'),
        meta: {
          title: 'ä»ªè¡¨æ¿',
          icon: 'dashboard',
          permissions: ['dashboard:view']
        }
      },
      {
        path: 'users',
        name: 'Users',
        component: () => import('@/pages/users/UserList.vue'),
        meta: {
          title: 'ç”¨æˆ·ç®¡ç†',
          icon: 'user',
          permissions: ['user:view']
        }
      },
      {
        path: 'users/:id',
        name: 'UserDetail',
        component: () => import('@/pages/users/UserDetail.vue'),
        meta: {
          title: 'ç”¨æˆ·è¯¦æƒ…',
          permissions: ['user:view'],
          hidden: true
        }
      },
      {
        path: 'documents',
        name: 'Documents',
        component: () => import('@/pages/documents/DocumentList.vue'),
        meta: {
          title: 'æ–‡æ¡£ç®¡ç†',
          icon: 'document',
          permissions: ['document:view']
        }
      }
    ]
  },
  {
    path: '/:pathMatch(.*)*',
    name: 'NotFound',
    component: () => import('@/pages/error/NotFound.vue'),
    meta: {
      title: 'é¡µé¢ä¸å­˜åœ¨'
    }
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes,
  scrollBehavior(to, from, savedPosition) {
    if (savedPosition) {
      return savedPosition
    } else {
      return { top: 0 }
    }
  }
})

// è·¯ç”±å®ˆå«
router.beforeEach(async (to, from, next) => {
  const authStore = useAuthStore()
  
  // è®¾ç½®é¡µé¢æ ‡é¢˜
  document.title = to.meta.title ? `${to.meta.title} - Junmo Platform` : 'Junmo Platform'
  
  // æ£€æŸ¥æ˜¯å¦éœ€è¦è®¤è¯
  if (to.meta.requiresAuth !== false && !authStore.isAuthenticated) {
    next('/auth/login')
    return
  }
  
  // å¦‚æœå·²ç™»å½•è®¿é—®ç™»å½•é¡µï¼Œé‡å®šå‘åˆ°é¦–é¡µ
  if (authStore.isAuthenticated && to.path.startsWith('/auth')) {
    next('/dashboard')
    return
  }
  
  // æ£€æŸ¥æƒé™
  if (to.meta.permissions) {
    const hasPermission = to.meta.permissions.some((permission: string) => 
      authStore.hasPermission(permission)
    )
    
    if (!hasPermission) {
      next('/403')
      return
    }
  }
  
  next()
})

export default router
```

## ğŸ¨ ç”¨æˆ·ç•Œé¢è®¾è®¡

### 1. å“åº”å¼å¸ƒå±€ç³»ç»Ÿ

**CSS Grid + Flexboxå¸ƒå±€**:

```scss
// styles/layout.scss
.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 16px;
  
  @media (min-width: 768px) {
    padding: 0 24px;
  }
  
  @media (min-width: 1024px) {
    padding: 0 32px;
  }
}

.grid {
  display: grid;
  gap: 16px;
  
  &--cols-1 { grid-template-columns: 1fr; }
  &--cols-2 { grid-template-columns: repeat(2, 1fr); }
  &--cols-3 { grid-template-columns: repeat(3, 1fr); }
  &--cols-4 { grid-template-columns: repeat(4, 1fr); }
  
  @media (max-width: 768px) {
    &--cols-2,
    &--cols-3,
    &--cols-4 {
      grid-template-columns: 1fr;
    }
  }
  
  @media (min-width: 769px) and (max-width: 1024px) {
    &--cols-3,
    &--cols-4 {
      grid-template-columns: repeat(2, 1fr);
    }
  }
}

.flex {
  display: flex;
  
  &--center {
    align-items: center;
    justify-content: center;
  }
  
  &--between {
    justify-content: space-between;
  }
  
  &--column {
    flex-direction: column;
  }
  
  &--wrap {
    flex-wrap: wrap;
  }
}
```

**ä¸»å¸ƒå±€ç»„ä»¶**:

```vue
<!-- layouts/DefaultLayout.vue -->
<template>
  <div class="default-layout">
    <!-- ä¾§è¾¹æ  -->
    <aside class="sidebar" :class="{ 'sidebar--collapsed': sidebarCollapsed }">
      <div class="sidebar__header">
        <div class="logo">
          <img src="/logo.svg" alt="Junmo Platform" />
          <span v-show="!sidebarCollapsed">Junmo Platform</span>
        </div>
        <button class="sidebar__toggle" @click="toggleSidebar">
          <el-icon><Menu /></el-icon>
        </button>
      </div>
      
      <nav class="sidebar__nav">
        <el-menu
          :default-active="$route.path"
          :collapse="sidebarCollapsed"
          router
          unique-opened
        >
          <template v-for="route in menuRoutes" :key="route.path">
            <el-menu-item
              v-if="!route.meta?.hidden"
              :index="route.path"
              :disabled="!hasRoutePermission(route)"
            >
              <el-icon v-if="route.meta?.icon">
                <component :is="route.meta.icon" />
              </el-icon>
              <template #title>{{ route.meta?.title }}</template>
            </el-menu-item>
          </template>
        </el-menu>
      </nav>
    </aside>
    
    <!-- ä¸»å†…å®¹åŒº -->
    <div class="main-content">
      <!-- é¡¶éƒ¨å¯¼èˆª -->
      <header class="header">
        <div class="header__left">
          <el-breadcrumb separator="/">
            <el-breadcrumb-item
              v-for="item in breadcrumbs"
              :key="item.path"
              :to="item.path"
            >
              {{ item.title }}
            </el-breadcrumb-item>
          </el-breadcrumb>
        </div>
        
        <div class="header__right">
          <!-- é€šçŸ¥ä¸­å¿ƒ -->
          <el-dropdown @command="handleNotificationCommand">
            <el-badge :value="unreadCount" :hidden="unreadCount === 0">
              <el-button :icon="Bell" circle />
            </el-badge>
            <template #dropdown>
              <el-dropdown-menu>
                <el-dropdown-item command="view-all">æŸ¥çœ‹å…¨éƒ¨</el-dropdown-item>
                <el-dropdown-item command="mark-all-read">å…¨éƒ¨æ ‡ä¸ºå·²è¯»</el-dropdown-item>
              </el-dropdown-menu>
            </template>
          </el-dropdown>
          
          <!-- ç”¨æˆ·èœå• -->
          <el-dropdown @command="handleUserCommand">
            <div class="user-info">
              <el-avatar :src="user?.avatarUrl" :size="32">
                {{ user?.username?.charAt(0)?.toUpperCase() }}
              </el-avatar>
              <span class="username">{{ user?.username }}</span>
              <el-icon><ArrowDown /></el-icon>
            </div>
            <template #dropdown>
              <el-dropdown-menu>
                <el-dropdown-item command="profile">ä¸ªäººèµ„æ–™</el-dropdown-item>
                <el-dropdown-item command="settings">ç³»ç»Ÿè®¾ç½®</el-dropdown-item>
                <el-dropdown-item divided command="logout">é€€å‡ºç™»å½•</el-dropdown-item>
              </el-dropdown-menu>
            </template>
          </el-dropdown>
        </div>
      </header>
      
      <!-- é¡µé¢å†…å®¹ -->
      <main class="content">
        <router-view v-slot="{ Component, route }">
          <transition name="fade" mode="out-in">
            <component :is="Component" :key="route.path" />
          </transition>
        </router-view>
      </main>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import { useAuthStore } from '@/stores/auth'
import { useNotificationStore } from '@/stores/notification'
import { 
  Menu, Bell, ArrowDown 
} from '@element-plus/icons-vue'

const route = useRoute()
const router = useRouter()
const authStore = useAuthStore()
const notificationStore = useNotificationStore()

// å“åº”å¼æ•°æ®
const sidebarCollapsed = ref(false)

// è®¡ç®—å±æ€§
const user = computed(() => authStore.user)
const unreadCount = computed(() => notificationStore.unreadCount)

const menuRoutes = computed(() => {
  return router.getRoutes().filter(route => 
    route.meta?.title && 
    route.meta?.requiresAuth !== false &&
    !route.meta?.hidden
  )
})

const breadcrumbs = computed(() => {
  const matched = route.matched.filter(item => item.meta?.title)
  return matched.map(item => ({
    path: item.path,
    title: item.meta?.title
  }))
})

// æ–¹æ³•
const toggleSidebar = () => {
  sidebarCollapsed.value = !sidebarCollapsed.value
}

const hasRoutePermission = (route: any) => {
  if (!route.meta?.permissions) return true
  return route.meta.permissions.some((permission: string) => 
    authStore.hasPermission(permission)
  )
}

const handleNotificationCommand = (command: string) => {
  switch (command) {
    case 'view-all':
      router.push('/notifications')
      break
    case 'mark-all-read':
      notificationStore.markAllAsRead()
      break
  }
}

const handleUserCommand = (command: string) => {
  switch (command) {
    case 'profile':
      router.push('/profile')
      break
    case 'settings':
      router.push('/settings')
      break
    case 'logout':
      authStore.logout()
      break
  }
}

// ç”Ÿå‘½å‘¨æœŸ
onMounted(() => {
  notificationStore.loadUnreadCount()
})
</script>

<style scoped lang="scss">
.default-layout {
  display: flex;
  height: 100vh;
}

.sidebar {
  width: 240px;
  background: #304156;
  color: white;
  transition: width 0.3s ease;
  
  &--collapsed {
    width: 64px;
  }
  
  &__header {
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 16px;
    border-bottom: 1px solid #434a50;
    
    .logo {
      display: flex;
      align-items: center;
      gap: 8px;
      
      img {
        width: 32px;
        height: 32px;
      }
      
      span {
        font-size: 18px;
        font-weight: bold;
      }
    }
    
    &__toggle {
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      padding: 8px;
      
      &:hover {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
      }
    }
  }
  
  &__nav {
    height: calc(100% - 60px);
    overflow-y: auto;
  }
}

.main-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.header {
  height: 60px;
  background: white;
  border-bottom: 1px solid #e4e7ed;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 24px;
  
  &__right {
    display: flex;
    align-items: center;
    gap: 16px;
  }
}

.user-info {
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  padding: 8px;
  border-radius: 4px;
  
  &:hover {
    background: #f5f7fa;
  }
  
  .username {
    font-size: 14px;
    color: #606266;
  }
}

.content {
  flex: 1;
  padding: 24px;
  overflow-y: auto;
  background: #f0f2f5;
}

// é¡µé¢åˆ‡æ¢åŠ¨ç”»
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.3s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}
</style>
```

### 2. ç»„ä»¶è®¾è®¡ç³»ç»Ÿ

**é€šç”¨æŒ‰é’®ç»„ä»¶**:

```vue
<!-- components/common/BaseButton.vue -->
<template>
  <el-button
    :type="type"
    :size="size"
    :loading="loading"
    :disabled="disabled || loading"
    :icon="icon"
    :circle="circle"
    :round="round"
    :plain="plain"
    :class="[
      'base-button',
      `base-button--${type}`,
      `base-button--${size}`,
      {
        'base-button--loading': loading,
        'base-button--disabled': disabled
      }
    ]"
    @click="handleClick"
  >
    <template v-if="$slots.loading && loading">
      <slot name="loading" />
    </template>
    
    <template v-else>
      <el-icon v-if="icon && $slots.default">
        <component :is="icon" />
      </el-icon>
      
      <slot v-if="$slots.default" />
      
      <el-icon v-else-if="icon">
        <component :is="icon" />
      </el-icon>
    </template>
  </el-button>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import type { ButtonProps } from 'element-plus'

interface Props extends ButtonProps {
  loading?: boolean
  icon?: string
}

const props = withDefaults(defineProps<Props>(), {
  loading: false,
  size: 'default'
})

const emit = defineEmits<{
  click: [event: MouseEvent]
}>()

const handleClick = (event: MouseEvent) => {
  if (!props.disabled && !props.loading) {
    emit('click', event)
  }
}
</script>

<style scoped lang="scss">
.base-button {
  transition: all 0.3s ease;
  
  &--primary {
    background: linear-gradient(135deg, #409eff 0%, #66b1ff 100%);
    border: none;
    
    &:hover {
      background: linear-gradient(135deg, #337ecc 0%, #5a9fff 100%);
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(64, 158, 255, 0.3);
    }
  }
  
  &--success {
    background: linear-gradient(135deg, #67c23a 0%, #85ce61 100%);
    border: none;
    
    &:hover {
      background: linear-gradient(135deg, #529b2e 0%, #73c050 100%);
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(103, 194, 58, 0.3);
    }
  }
  
  &--loading {
    pointer-events: none;
  }
  
  &--disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
}
</style>
```

**æ•°æ®è¡¨æ ¼ç»„ä»¶**:

```vue
<!-- components/table/BaseTable.vue -->
<template>
  <div class="base-table">
    <!-- è¡¨æ ¼å·¥å…·æ  -->
    <div class="table-toolbar" v-if="showToolbar">
      <div class="toolbar-left">
        <slot name="toolbar-left">
          <base-button
            v-if="showRefresh"
            type="primary"
            :icon="Refresh"
            @click="handleRefresh"
          >
            åˆ·æ–°
          </base-button>
          
          <base-button
            v-if="showAdd"
            type="success"
            :icon="Plus"
            @click="handleAdd"
          >
            æ–°å¢
          </base-button>
        </slot>
      </div>
      
      <div class="toolbar-right">
        <slot name="toolbar-right">
          <el-input
            v-if="showSearch"
            v-model="searchKeyword"
            placeholder="æœç´¢..."
            :prefix-icon="Search"
            clearable
            @input="handleSearch"
          />
        </slot>
      </div>
    </div>
    
    <!-- è¡¨æ ¼ä¸»ä½“ -->
    <el-table
      ref="tableRef"
      :data="data"
      :loading="loading"
      :height="height"
      :max-height="maxHeight"
      :stripe="stripe"
      :border="border"
      :size="size"
      :fit="fit"
      :show-header="showHeader"
      :highlight-current-row="highlightCurrentRow"
      :row-key="rowKey"
      :empty-text="emptyText"
      :default-expand-all="defaultExpandAll"
      :expand-row-keys="expandRowKeys"
      :default-sort="defaultSort"
      :tooltip-effect="tooltipEffect"
      :show-summary="showSummary"
      :sum-text="sumText"
      :summary-method="summaryMethod"
      :span-method="spanMethod"
      :select-on-indeterminate="selectOnIndeterminate"
      :indent="indent"
      :lazy="lazy"
      :load="load"
      :tree-props="treeProps"
      @select="handleSelect"
      @select-all="handleSelectAll"
      @selection-change="handleSelectionChange"
      @cell-mouse-enter="handleCellMouseEnter"
      @cell-mouse-leave="handleCellMouseLeave"
      @cell-click="handleCellClick"
      @cell-dblclick="handleCellDblclick"
      @row-click="handleRowClick"
      @row-contextmenu="handleRowContextmenu"
      @row-dblclick="handleRowDblclick"
      @header-click="handleHeaderClick"
      @header-contextmenu="handleHeaderContextmenu"
      @sort-change="handleSortChange"
      @filter-change="handleFilterChange"
      @current-change="handleCurrentChange"
      @header-dragend="handleHeaderDragend"
      @expand-change="handleExpandChange"
    >
      <!-- é€‰æ‹©åˆ— -->
      <el-table-column
        v-if="showSelection"
        type="selection"
        width="55"
        :selectable="selectable"
        :reserve-selection="reserveSelection"
      />
      
      <!-- åºå·åˆ— -->
      <el-table-column
        v-if="showIndex"
        type="index"
        label="åºå·"
        width="60"
        :index="indexMethod"
      />
      
      <!-- æ•°æ®åˆ— -->
      <template v-for="column in columns" :key="column.prop">
        <el-table-column
          :prop="column.prop"
          :label="column.label"
          :width="column.width"
          :min-width="column.minWidth"
          :fixed="column.fixed"
          :render-header="column.renderHeader"
          :sortable="column.sortable"
          :sort-method="column.sortMethod"
          :sort-by="column.sortBy"
          :sort-orders="column.sortOrders"
          :resizable="column.resizable"
          :formatter="column.formatter"
          :show-overflow-tooltip="column.showOverflowTooltip"
          :align="column.align"
          :header-align="column.headerAlign"
          :class-name="column.className"
          :label-class-name="column.labelClassName"
          :selectable="column.selectable"
          :reserve-selection="column.reserveSelection"
          :filters="column.filters"
          :filter-placement="column.filterPlacement"
          :filter-multiple="column.filterMultiple"
          :filter-method="column.filterMethod"
          :filtered-value="column.filteredValue"
        >
          <template #default="scope">
            <slot
              :name="`column-${column.prop}`"
              v-bind="scope"
            >
              <span v-if="!column.slot">
                {{ formatCellValue(scope.row, column) }}
              </span>
            </slot>
          </template>
        </el-table-column>
      </template>
      
      <!-- æ“ä½œåˆ— -->
      <el-table-column
        v-if="showActions"
        label="æ“ä½œ"
        :width="actionWidth"
        :fixed="actionFixed"
      >
        <template #default="scope">
          <slot name="actions" v-bind="scope">
            <el-button
              v-if="showEdit"
              type="primary"
              size="small"
              @click="handleEdit(scope.row, scope.$index)"
            >
              ç¼–è¾‘
            </el-button>
            
            <el-button
              v-if="showDelete"
              type="danger"
              size="small"
              @click="handleDelete(scope.row, scope.$index)"
            >
              åˆ é™¤
            </el-button>
          </slot>
        </template>
      </el-table-column>
    </el-table>
    
    <!-- åˆ†é¡µ -->
    <div class="table-pagination" v-if="showPagination">
      <el-pagination
        :current-page="pagination.currentPage"
        :page-size="pagination.pageSize"
        :page-sizes="pagination.pageSizes"
        :total="pagination.total"
        :layout="pagination.layout"
        :background="pagination.background"
        :small="pagination.small"
        @size-change="handleSizeChange"
        @current-change="handleCurrentChange"
      />
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, watch } from 'vue'
import { ElTable } from 'element-plus'
import type { TableColumnCtx } from 'element-plus'
import { 
  Refresh, Plus, Search 
} from '@element-plus/icons-vue'

interface Column {
  prop: string
  label: string
  width?: number | string
  minWidth?: number | string
  fixed?: boolean | 'left' | 'right'
  sortable?: boolean | 'custom'
  sortMethod?: (a: any, b: any) => number
  sortBy?: string | string[]
  sortOrders?: ('ascending' | 'descending' | null)[]
  resizable?: boolean
  formatter?: (row: any, column: TableColumnCtx<any>, cellValue: any) => string
  showOverflowTooltip?: boolean
  align?: 'left' | 'center' | 'right'
  headerAlign?: 'left' | 'center' | 'right'
  className?: string
  labelClassName?: string
  selectable?: (row: any, index: number) => boolean
  reserveSelection?: boolean
  filters?: { text: string; value: any }[]
  filterPlacement?: string
  filterMultiple?: boolean
  filterMethod?: (value: any, row: any) => boolean
  filteredValue?: any[]
  slot?: boolean
}

interface Pagination {
  currentPage: number
  pageSize: number
  total: number
  pageSizes?: number[]
  layout?: string
  background?: boolean
  small?: boolean
}

interface Props {
  data: any[]
  columns: Column[]
  loading?: boolean
  height?: string | number
  maxHeight?: string | number
  stripe?: boolean
  border?: boolean
  size?: 'large' | 'default' | 'small'
  fit?: boolean
  showHeader?: boolean
  highlightCurrentRow?: boolean
  emptyText?: string
  rowKey?: string | ((row: any) => string)
  defaultExpandAll?: boolean
  expandRowKeys?: string[]
  defaultSort?: { prop: string; order: 'ascending' | 'descending' }
  tooltipEffect?: 'dark' | 'light'
  showSummary?: boolean
  sumText?: string
  summaryMethod?: (param: any) => string[]
  spanMethod?: (param: any) => number[] | { rowspan: number; colspan: number }
  selectOnIndeterminate?: boolean
  indent?: number
  lazy?: boolean
  load?: (row: any, treeNode: any, resolve: (data: any[]) => void) => void
  treeProps?: { hasChildren?: string; children?: string }
  
  // å·¥å…·æ é…ç½®
  showToolbar?: boolean
  showRefresh?: boolean
  showAdd?: boolean
  showSearch?: boolean
  
  // åˆ—é…ç½®
  showSelection?: boolean
  showIndex?: boolean
  showActions?: boolean
  actionWidth?: number | string
  actionFixed?: boolean | 'left' | 'right'
  showEdit?: boolean
  showDelete?: boolean
  
  // åˆ†é¡µé…ç½®
  showPagination?: boolean
  pagination?: Pagination
}

const props = withDefaults(defineProps<Props>(), {
  loading: false,
  stripe: true,
  border: true,
  size: 'default',
  fit: true,
  showHeader: true,
  highlightCurrentRow: true,
  emptyText: 'æš‚æ— æ•°æ®',
  tooltipEffect: 'dark',
  showSummary: false,
  sumText: 'åˆè®¡',
  selectOnIndeterminate: true,
  indent: 16,
  
  showToolbar: true,
  showRefresh: true,
  showAdd: false,
  showSearch: true,
  
  showSelection: false,
  showIndex: false,
  showActions: true,
  actionWidth: 150,
  showEdit: true,
  showDelete: true,
  
  showPagination: true
})

const emit = defineEmits<{
  refresh: []
  add: []
  edit: [row: any, index: number]
  delete: [row: any, index: number]
  search: [keyword: string]
  'size-change': [size: number]
  'current-change': [current: number]
  selection: [selection: any[]]
}>()

// å“åº”å¼æ•°æ®
const tableRef = ref<InstanceType<typeof ElTable>>()
const searchKeyword = ref('')

// æ–¹æ³•
const handleRefresh = () => {
  emit('refresh')
}

const handleAdd = () => {
  emit('add')
}

const handleEdit = (row: any, index: number) => {
  emit('edit', row, index)
}

const handleDelete = (row: any, index: number) => {
  emit('delete', row, index)
}

const handleSearch = () => {
  emit('search', searchKeyword.value)
}

const handleSizeChange = (size: number) => {
  emit('size-change', size)
}

const handleCurrentChange = (current: number) => {
  emit('current-change', current)
}

const handleSelectionChange = (selection: any[]) => {
  emit('selection', selection)
}

const formatCellValue = (row: any, column: Column) => {
  const value = row[column.prop]
  
  if (column.formatter) {
    return column.formatter(row, column as TableColumnCtx<any>, value)
  }
  
  return value
}

const indexMethod = (index: number) => {
  if (props.showPagination) {
    return (props.pagination!.currentPage - 1) * props.pagination!.pageSize + index + 1
  }
  return index + 1
}

// æš´éœ²æ–¹æ³•
defineExpose({
  tableRef,
  clearSelection: () => tableRef.value?.clearSelection(),
  toggleRowSelection: (row: any, selected?: boolean) => 
    tableRef.value?.toggleRowSelection(row, selected),
  toggleAllSelection: () => tableRef.value?.toggleAllSelection(),
  toggleRowExpansion: (row: any, expanded?: boolean) => 
    tableRef.value?.toggleRowExpansion(row, expanded),
  setCurrentRow: (row: any) => tableRef.value?.setCurrentRow(row),
  clearSort: () => tableRef.value?.clearSort(),
  clearFilter: (columnKeys?: string[]) => tableRef.value?.clearFilter(columnKeys),
  doLayout: () => tableRef.value?.doLayout(),
  sort: (prop: string, order: 'ascending' | 'descending') => 
    tableRef.value?.sort(prop, order)
})
</script>

<style scoped lang="scss">
.base-table {
  background: white;
  border-radius: 8px;
  overflow: hidden;
  
  .table-toolbar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px;
    border-bottom: 1px solid #e4e7ed;
    
    .toolbar-left {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .toolbar-right {
      display: flex;
      align-items: center;
      gap: 8px;
    }
  }
  
  .table-pagination {
    padding: 16px;
    display: flex;
    justify-content: flex-end;
    border-top: 1px solid #e4e7ed;
  }
}
</style>
```

## ğŸ”„ å®æ—¶é€šä¿¡è®¾è®¡

### 1. WebSocketé›†æˆ

**WebSocketæœåŠ¡**:

```typescript
// composables/useWebSocket.ts
import { ref, onUnmounted } from 'vue'
import { useAuthStore } from '@/stores/auth'

interface WebSocketMessage {
  type: string
  data: any
  timestamp: number
}

interface WebSocketOptions {
  url: string
  protocols?: string | string[]
  reconnectInterval?: number
  maxReconnectAttempts?: number
}

export function useWebSocket(options: WebSocketOptions) {
  const {
    url,
    protocols,
    reconnectInterval = 3000,
    maxReconnectAttempts = 5
  } = options
  
  const authStore = useAuthStore()
  
  // å“åº”å¼çŠ¶æ€
  const isConnected = ref(false)
  const isReconnecting = ref(false)
  const error = ref<Error | null>(null)
  const reconnectAttempts = ref(0)
  
  let ws: WebSocket | null = null
  let reconnectTimer: NodeJS.Timeout | null = null
  let messageQueue: WebSocketMessage[] = []
  
  // äº‹ä»¶å¤„ç†å™¨
  const onOpen = (event: Event) => {
    console.log('WebSocket connected')
    isConnected.value = true
    isReconnecting.value = false
    reconnectAttempts.value = 0
    error.value = null
    
    // å‘é€è®¤è¯ä¿¡æ¯
    if (authStore.token) {
      send({
        type: 'auth',
        data: {
          token: authStore.token
        }
      })
    }
    
    // å‘é€é˜Ÿåˆ—ä¸­çš„æ¶ˆæ¯
    while (messageQueue.length > 0) {
      const message = messageQueue.shift()
      if (message) {
        ws?.send(JSON.stringify(message))
      }
    }
  }
  
  const onMessage = (event: MessageEvent) => {
    try {
      const message: WebSocketMessage = JSON.parse(event.data)
      handleMessage(message)
    } catch (err) {
      console.error('Failed to parse WebSocket message:', err)
    }
  }
  
  const onClose = (event: CloseEvent) => {
    console.log('WebSocket disconnected')
    isConnected.value = false
    
    // å¦‚æœä¸æ˜¯ä¸»åŠ¨å…³é—­ï¼Œå°è¯•é‡è¿
    if (!event.wasClean && reconnectAttempts.value < maxReconnectAttempts) {
      scheduleReconnect()
    }
  }
  
  const onError = (event: Event) => {
    console.error('WebSocket error:', event)
    error.value = new Error('WebSocket connection error')
  }
  
  // æ¶ˆæ¯å¤„ç†
  const handleMessage = (message: WebSocketMessage) => {
    switch (message.type) {
      case 'auth_success':
        console.log('WebSocket authentication successful')
        break
      case 'auth_error':
        console.error('WebSocket authentication failed')
        close()
        break
      case 'notification':
        // å¤„ç†é€šçŸ¥æ¶ˆæ¯
        handleNotification(message.data)
        break
      case 'document_update':
        // å¤„ç†æ–‡æ¡£æ›´æ–°æ¶ˆæ¯
        handleDocumentUpdate(message.data)
        break
      case 'workflow_update':
        // å¤„ç†å·¥ä½œæµæ›´æ–°æ¶ˆæ¯
        handleWorkflowUpdate(message.data)
        break
      default:
        console.log('Unknown message type:', message.type)
    }
  }
  
  const handleNotification = (data: any) => {
    // è§¦å‘é€šçŸ¥äº‹ä»¶
    window.dispatchEvent(new CustomEvent('websocket:notification', { 
      detail: data 
    }))
  }
  
  const handleDocumentUpdate = (data: any) => {
    // è§¦å‘æ–‡æ¡£æ›´æ–°äº‹ä»¶
    window.dispatchEvent(new CustomEvent('websocket:document_update', { 
      detail: data 
    }))
  }
  
  const handleWorkflowUpdate = (data: any) => {
    // è§¦å‘å·¥ä½œæµæ›´æ–°äº‹ä»¶
    window.dispatchEvent(new CustomEvent('websocket:workflow_update', { 
      detail: data 
    }))
  }
  
  // è¿æ¥ç®¡ç†
  const connect = () => {
    if (ws?.readyState === WebSocket.OPEN) {
      return
    }
    
    try {
      const wsUrl = `${url}?token=${authStore.token}`
      ws = new WebSocket(wsUrl, protocols)
      
      ws.onopen = onOpen
      ws.onmessage = onMessage
      ws.onclose = onClose
      ws.onerror = onError
    } catch (err) {
      error.value = err as Error
      scheduleReconnect()
    }
  }
  
  const close = () => {
    if (reconnectTimer) {
      clearTimeout(reconnectTimer)
      reconnectTimer = null
    }
    
    if (ws) {
      ws.close()
      ws = null
    }
    
    isConnected.value = false
    isReconnecting.value = false
  }
  
  const scheduleReconnect = () => {
    if (reconnectAttempts.value >= maxReconnectAttempts) {
      console.error('Max reconnect attempts reached')
      return
    }
    
    isReconnecting.value = true
    reconnectAttempts.value++
    
    reconnectTimer = setTimeout(() => {
      console.log(`Reconnecting... Attempt ${reconnectAttempts.value}`)
      connect()
    }, reconnectInterval)
  }
  
  // æ¶ˆæ¯å‘é€
  const send = (message: WebSocketMessage) => {
    if (isConnected.value && ws?.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(message))
    } else {
      // è¿æ¥æœªå°±ç»ªï¼ŒåŠ å…¥é˜Ÿåˆ—
      messageQueue.push(message)
    }
  }
  
  // ç”Ÿå‘½å‘¨æœŸ
  onUnmounted(() => {
    close()
  })
  
  return {
    // çŠ¶æ€
    isConnected,
    isReconnecting,
    error,
    reconnectAttempts,
    
    // æ–¹æ³•
    connect,
    close,
    send
  }
}
```

**å®æ—¶é€šçŸ¥ç»„ä»¶**:

```vue
<!-- components/common/NotificationCenter.vue -->
<template>
  <div class="notification-center">
    <!-- é€šçŸ¥æŒ‰é’® -->
    <el-badge :value="unreadCount" :hidden="unreadCount === 0" :max="99">
      <el-button 
        :icon="Bell" 
        circle 
        @click="showNotifications = !showNotifications"
      />
    </el-badge>
    
    <!-- é€šçŸ¥é¢æ¿ -->
    <el-drawer
      v-model="showNotifications"
      title="é€šçŸ¥ä¸­å¿ƒ"
      direction="rtl"
      size="400px"
    >
      <div class="notification-content">
        <!-- å·¥å…·æ  -->
        <div class="notification-toolbar">
          <el-button 
            size="small" 
            @click="markAllAsRead"
            :disabled="unreadCount === 0"
          >
            å…¨éƒ¨æ ‡ä¸ºå·²è¯»
          </el-button>
          <el-button 
            size="small" 
            @click="clearAll"
          >
            æ¸…ç©ºå…¨éƒ¨
          </el-button>
        </div>
        
        <!-- é€šçŸ¥åˆ—è¡¨ -->
        <div class="notification-list">
          <div
            v-for="notification in notifications"
            :key="notification.id"
            class="notification-item"
            :class="{ 'notification-item--unread': !notification.read }"
            @click="handleNotificationClick(notification)"
          >
            <div class="notification-icon">
              <el-icon :color="getNotificationColor(notification.type)">
                <component :is="getNotificationIcon(notification.type)" />
              </el-icon>
            </div>
            
            <div class="notification-content">
              <div class="notification-title">
                {{ notification.title }}
              </div>
              <div class="notification-message">
                {{ notification.message }}
              </div>
              <div class="notification-time">
                {{ formatTime(notification.createdAt) }}
              </div>
            </div>
            
            <div class="notification-actions">
              <el-button
                v-if="!notification.read"
                size="small"
                text
                @click.stop="markAsRead(notification)"
              >
                æ ‡ä¸ºå·²è¯»
              </el-button>
              <el-button
                size="small"
                text
                @click.stop="deleteNotification(notification)"
              >
                åˆ é™¤
              </el-button>
            </div>
          </div>
          
          <!-- åŠ è½½æ›´å¤š -->
          <div
            v-if="hasMore"
            class="notification-load-more"
            @click="loadMore"
          >
            <el-button :loading="loading" text>
              åŠ è½½æ›´å¤š
            </el-button>
          </div>
        </div>
      </div>
    </el-drawer>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue'
import { useNotificationStore } from '@/stores/notification'
import { useWebSocket } from '@/composables/useWebSocket'
import { 
  Bell, 
  InfoFilled, 
  SuccessFilled, 
  WarningFilled, 
  CircleCloseFilled 
} from '@element-plus/icons-vue'
import type { Notification } from '@/types/notification'

const notificationStore = useNotificationStore()

// WebSocketè¿æ¥
const { isConnected } = useWebSocket({
  url: 'ws://localhost:8080/ws/notifications'
})

// å“åº”å¼æ•°æ®
const showNotifications = ref(false)
const notifications = ref<Notification[]>([])
const unreadCount = ref(0)
const loading = ref(false)
const hasMore = ref(true)
const currentPage = ref(1)
const pageSize = ref(20)

// è®¡ç®—å±æ€§
const getNotificationIcon = (type: string) => {
  const iconMap = {
    info: InfoFilled,
    success: SuccessFilled,
    warning: WarningFilled,
    error: CircleCloseFilled
  }
  return iconMap[type] || InfoFilled
}

const getNotificationColor = (type: string) => {
  const colorMap = {
    info: '#409eff',
    success: '#67c23a',
    warning: '#e6a23c',
    error: '#f56c6c'
  }
  return colorMap[type] || '#409eff'
}

// æ–¹æ³•
const loadNotifications = async () => {
  try {
    loading.value = true
    
    const response = await notificationStore.getNotifications({
      page: currentPage.value,
      size: pageSize.value
    })
    
    if (currentPage.value === 1) {
      notifications.value = response.data.content
    } else {
      notifications.value.push(...response.data.content)
    }
    
    hasMore.value = !response.data.last
    unreadCount.value = response.data.unreadCount
  } catch (error) {
    console.error('Failed to load notifications:', error)
  } finally {
    loading.value = false
  }
}

const loadMore = () => {
  if (!loading.value && hasMore.value) {
    currentPage.value++
    loadNotifications()
  }
}

const markAsRead = async (notification: Notification) => {
  try {
    await notificationStore.markAsRead(notification.id)
    notification.read = true
    unreadCount.value = Math.max(0, unreadCount.value - 1)
  } catch (error) {
    console.error('Failed to mark notification as read:', error)
  }
}

const markAllAsRead = async () => {
  try {
    await notificationStore.markAllAsRead()
    notifications.value.forEach(notification => {
      notification.read = true
    })
    unreadCount.value = 0
  } catch (error) {
    console.error('Failed to mark all notifications as read:', error)
  }
}

const deleteNotification = async (notification: Notification) => {
  try {
    await notificationStore.deleteNotification(notification.id)
    const index = notifications.value.findIndex(n => n.id === notification.id)
    if (index > -1) {
      notifications.value.splice(index, 1)
      if (!notification.read) {
        unreadCount.value = Math.max(0, unreadCount.value - 1)
      }
    }
  } catch (error) {
    console.error('Failed to delete notification:', error)
  }
}

const clearAll = async () => {
  try {
    await notificationStore.clearAll()
    notifications.value = []
    unreadCount.value = 0
  } catch (error) {
    console.error('Failed to clear all notifications:', error)
  }
}

const handleNotificationClick = (notification: Notification) => {
  if (!notification.read) {
    markAsRead(notification)
  }
  
  // å¤„ç†é€šçŸ¥ç‚¹å‡»é€»è¾‘
  if (notification.actionUrl) {
    window.open(notification.actionUrl, '_blank')
  }
}

const formatTime = (time: string) => {
  const date = new Date(time)
  const now = new Date()
  const diff = now.getTime() - date.getTime()
  
  if (diff < 60000) {
    return 'åˆšåˆš'
  } else if (diff < 3600000) {
    return `${Math.floor(diff / 60000)}åˆ†é’Ÿå‰`
  } else if (diff < 86400000) {
    return `${Math.floor(diff / 3600000)}å°æ—¶å‰`
  } else {
    return date.toLocaleDateString()
  }
}

// WebSocketäº‹ä»¶ç›‘å¬
const handleWebSocketNotification = (event: CustomEvent) => {
  const notification = event.detail
  
  // æ·»åŠ åˆ°é€šçŸ¥åˆ—è¡¨é¡¶éƒ¨
  notifications.value.unshift(notification)
  
  // æ›´æ–°æœªè¯»æ•°é‡
  if (!notification.read) {
    unreadCount.value++
  }
  
  // æ˜¾ç¤ºæ¡Œé¢é€šçŸ¥
  if ('Notification' in window && Notification.permission === 'granted') {
    new Notification(notification.title, {
      body: notification.message,
      icon: '/favicon.ico'
    })
  }
}

// ç”Ÿå‘½å‘¨æœŸ
onMounted(() => {
  loadNotifications()
  
  // ç›‘å¬WebSocketé€šçŸ¥äº‹ä»¶
  window.addEventListener('websocket:notification', handleWebSocketNotification as EventListener)
  
  // è¯·æ±‚æ¡Œé¢é€šçŸ¥æƒé™
  if ('Notification' in window && Notification.permission === 'default') {
    Notification.requestPermission()
  }
})

onUnmounted(() => {
  window.removeEventListener('websocket:notification', handleWebSocketNotification as EventListener)
})
</script>

<style scoped lang="scss">
.notification-center {
  position: relative;
}

.notification-content {
  height: 100%;
  display: flex;
  flex-direction: column;
}

.notification-toolbar {
  padding: 16px;
  border-bottom: 1px solid #e4e7ed;
  display: flex;
  gap: 8px;
}

.notification-list {
  flex: 1;
  overflow-y: auto;
}

.notification-item {
  display: flex;
  align-items: flex-start;
  padding: 16px;
  border-bottom: 1px solid #f0f0f0;
  cursor: pointer;
  transition: background-color 0.3s ease;
  
  &:hover {
    background-color: #f5f7fa;
  }
  
  &--unread {
    background-color: #f0f9ff;
    border-left: 4px solid #409eff;
  }
}

.notification-icon {
  margin-right: 12px;
  margin-top: 2px;
}

.notification-content {
  flex: 1;
  min-width: 0;
}

.notification-title {
  font-weight: 500;
  color: #303133;
  margin-bottom: 4px;
}

.notification-message {
  color: #606266;
  font-size: 14px;
  line-height: 1.4;
  margin-bottom: 8px;
  word-break: break-word;
}

.notification-time {
  color: #909399;
  font-size: 12px;
}

.notification-actions {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-left: 8px;
}

.notification-load-more {
  padding: 16px;
  text-align: center;
  
  &:hover {
    background-color: #f5f7fa;
    cursor: pointer;
  }
}
</style>
```

## ğŸ“± ç§»åŠ¨ç«¯é€‚é…

### 1. å“åº”å¼è®¾è®¡æ–­ç‚¹

```scss
// styles/breakpoints.scss
$breakpoints: (
  xs: 0,
  sm: 576px,
  md: 768px,
  lg: 992px,
  xl: 1200px,
  xxl: 1400px
);

@mixin respond-to($breakpoint) {
  @if map-has-key($breakpoints, $breakpoint) {
    @media (min-width: map-get($breakpoints, $breakpoint)) {
      @content;
    }
  } @else {
    @warn "Unknown breakpoint: #{$breakpoint}.";
  }
}

@mixin respond-between($lower, $upper) {
  @if map-has-key($breakpoints, $lower) and map-has-key($breakpoints, $upper) {
    @media (min-width: map-get($breakpoints, $lower)) and (max-width: map-get($breakpoints, $upper) - 1px) {
      @content;
    }
  } @else {
    @warn "Unknown breakpoint(s): #{$lower}, #{$upper}.";
  }
}

// ä½¿ç”¨ç¤ºä¾‹
.container {
  padding: 16px;
  
  @include respond-to(md) {
    padding: 24px;
  }
  
  @include respond-to(lg) {
    padding: 32px;
  }
}

.grid {
  display: grid;
  grid-template-columns: 1fr;
  gap: 16px;
  
  @include respond-to(sm) {
    grid-template-columns: repeat(2, 1fr);
  }
  
  @include respond-to(lg) {
    grid-template-columns: repeat(3, 1fr);
  }
  
  @include respond-to(xl) {
    grid-template-columns: repeat(4, 1fr);
  }
}
```

### 2. ç§»åŠ¨ç«¯ä¼˜åŒ–

**è§¦æ‘¸å‹å¥½çš„äº¤äº’**:

```vue
<!-- components/common/MobileMenu.vue -->
<template>
  <div class="mobile-menu">
    <!-- èœå•æŒ‰é’® -->
    <el-button
      :icon="Menu"
      circle
      @click="showMenu = !showMenu"
      class="mobile-menu__toggle"
    />
    
    <!-- é®ç½©å±‚ -->
    <div
      v-show="showMenu"
      class="mobile-menu__overlay"
      @click="showMenu = false"
    />
    
    <!-- ä¾§è¾¹èœå• -->
    <transition name="slide-left">
      <div v-show="showMenu" class="mobile-menu__sidebar">
        <div class="mobile-menu__header">
          <div class="user-info">
            <el-avatar :size="40" :src="user?.avatarUrl">
              {{ user?.username?.charAt(0)?.toUpperCase() }}
            </el-avatar>
            <div class="user-details">
              <div class="username">{{ user?.username }}</div>
              <div class="user-role">{{ user?.roles?.join(', ') }}</div>
            </div>
          </div>
          
          <el-button
            :icon="Close"
            circle
            @click="showMenu = false"
            class="close-button"
          />
        </div>
        
        <nav class="mobile-menu__nav">
          <el-menu
            :default-active="$route.path"
            router
            :collapse="false"
          >
            <template v-for="route in menuRoutes" :key="route.path">
              <el-menu-item
                v-if="!route.meta?.hidden && hasRoutePermission(route)"
                :index="route.path"
                @click="showMenu = false"
              >
                <el-icon v-if="route.meta?.icon">
                  <component :is="route.meta.icon" />
                </el-icon>
                <template #title>{{ route.meta?.title }}</template>
              </el-menu-item>
            </template>
          </el-menu>
        </nav>
        
        <div class="mobile-menu__footer">
          <el-button
            type="danger"
            :icon="SwitchButton"
            @click="handleLogout"
          >
            é€€å‡ºç™»å½•
          </el-button>
        </div>
      </div>
    </transition>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import { useAuthStore } from '@/stores/auth'
import { 
  Menu, Close, SwitchButton 
} from '@element-plus/icons-vue'

const route = useRoute()
const router = useRouter()
const authStore = useAuthStore()

// å“åº”å¼æ•°æ®
const showMenu = ref(false)

// è®¡ç®—å±æ€§
const user = computed(() => authStore.user)

const menuRoutes = computed(() => {
  return router.getRoutes().filter(route => 
    route.meta?.title && 
    route.meta?.requiresAuth !== false &&
    !route.meta?.hidden
  )
})

// æ–¹æ³•
const hasRoutePermission = (route: any) => {
  if (!route.meta?.permissions) return true
  return route.meta.permissions.some((permission: string) => 
    authStore.hasPermission(permission)
  )
}

const handleLogout = () => {
  showMenu.value = false
  authStore.logout()
}
</script>

<style scoped lang="scss">
.mobile-menu {
  position: relative;
  
  &__toggle {
    @include respond-to(md) {
      display: none;
    }
  }
  
  &__overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    z-index: 1000;
  }
  
  &__sidebar {
    position: fixed;
    top: 0;
    left: 0;
    bottom: 0;
    width: 280px;
    background: white;
    z-index: 1001;
    display: flex;
    flex-direction: column;
    
    @include respond-to(md) {
      display: none;
    }
  }
  
  &__header {
    padding: 16px;
    border-bottom: 1px solid #e4e7ed;
    display: flex;
    align-items: center;
    justify-content: space-between;
    
    .user-info {
      display: flex;
      align-items: center;
      gap: 12px;
      
      .user-details {
        .username {
          font-weight: 500;
          color: #303133;
        }
        
        .user-role {
          font-size: 12px;
          color: #909399;
        }
      }
    }
    
    .close-button {
      background: none;
      border: none;
    }
  }
  
  &__nav {
    flex: 1;
    overflow-y: auto;
    
    .el-menu {
      border: none;
    }
  }
  
  &__footer {
    padding: 16px;
    border-top: 1px solid #e4e7ed;
  }
}

// æ»‘åŠ¨åŠ¨ç”»
.slide-left-enter-active,
.slide-left-leave-active {
  transition: transform 0.3s ease;
}

.slide-left-enter-from {
  transform: translateX(-100%);
}

.slide-left-leave-to {
  transform: translateX(-100%);
}
</style>
```

**æ‰‹åŠ¿æ“ä½œæ”¯æŒ**:

```typescript
// composables/useTouchGestures.ts
import { ref, onMounted, onUnmounted } from 'vue'

interface TouchGesturesOptions {
  onSwipeLeft?: () => void
  onSwipeRight?: () => void
  onSwipeUp?: () => void
  onSwipeDown?: () => void
  onTap?: () => void
  onLongPress?: () => void
  threshold?: number
  longPressDelay?: number
}

export function useTouchGestures(element: HTMLElement, options: TouchGesturesOptions) {
  const {
    onSwipeLeft,
    onSwipeRight,
    onSwipeUp,
    onSwipeDown,
    onTap,
    onLongPress,
    threshold = 50,
    longPressDelay = 500
  } = options
  
  const startX = ref(0)
  const startY = ref(0)
  const endX = ref(0)
  const endY = ref(0)
  const startTime = ref(0)
  const longPressTimer = ref<NodeJS.Timeout | null>(null)
  
  const handleTouchStart = (e: TouchEvent) => {
    const touch = e.touches[0]
    startX.value = touch.clientX
    startY.value = touch.clientY
    startTime.value = Date.now()
    
    // è®¾ç½®é•¿æŒ‰å®šæ—¶å™¨
    if (onLongPress) {
      longPressTimer.value = setTimeout(() => {
        onLongPress()
      }, longPressDelay)
    }
  }
  
  const handleTouchMove = (e: TouchEvent) => {
    const touch = e.touches[0]
    endX.value = touch.clientX
    endY.value = touch.clientY
    
    // å¦‚æœç§»åŠ¨è·ç¦»è¶…è¿‡é˜ˆå€¼ï¼Œå–æ¶ˆé•¿æŒ‰
    if (Math.abs(endX.value - startX.value) > threshold || 
        Math.abs(endY.value - startY.value) > threshold) {
      if (longPressTimer.value) {
        clearTimeout(longPressTimer.value)
        longPressTimer.value = null
      }
    }
  }
  
  const handleTouchEnd = (e: TouchEvent) => {
    const deltaX = endX.value - startX.value
    const deltaY = endY.value - startY.value
    const deltaTime = Date.now() - startTime.value
    
    // æ¸…é™¤é•¿æŒ‰å®šæ—¶å™¨
    if (longPressTimer.value) {
      clearTimeout(longPressTimer.value)
      longPressTimer.value = null
    }
    
    // åˆ¤æ–­æ‰‹åŠ¿ç±»å‹
    if (Math.abs(deltaX) > Math.abs(deltaY)) {
      // æ°´å¹³æ»‘åŠ¨
      if (Math.abs(deltaX) > threshold) {
        if (deltaX > 0 && onSwipeRight) {
          onSwipeRight()
        } else if (deltaX < 0 && onSwipeLeft) {
          onSwipeLeft()
        }
      }
    } else {
      // å‚ç›´æ»‘åŠ¨
      if (Math.abs(deltaY) > threshold) {
        if (deltaY > 0 && onSwipeDown) {
          onSwipeDown()
        } else if (deltaY < 0 && onSwipeUp) {
          onSwipeUp()
        }
      }
    }
    
    // ç‚¹å‡»
    if (Math.abs(deltaX) < threshold && 
        Math.abs(deltaY) < threshold && 
        deltaTime < 200 && 
        onTap) {
      onTap()
    }
  }
  
  onMounted(() => {
    element.addEventListener('touchstart', handleTouchStart, { passive: true })
    element.addEventListener('touchmove', handleTouchMove, { passive: true })
    element.addEventListener('touchend', handleTouchEnd, { passive: true })
  })
  
  onUnmounted(() => {
    element.removeEventListener('touchstart', handleTouchStart)
    element.removeEventListener('touchmove', handleTouchMove)
    element.removeEventListener('touchend', handleTouchEnd)
    
    if (longPressTimer.value) {
      clearTimeout(longPressTimer.value)
    }
  })
}
```

---

*æœ¬æ–‡æ¡£æä¾›äº†è¯¦ç»†çš„åº”ç”¨äº¤äº’è®¾è®¡ï¼ŒåŒ…æ‹¬å‰ç«¯æ¶æ„ã€ç»„ä»¶è®¾è®¡ã€å®æ—¶é€šä¿¡å’Œç§»åŠ¨ç«¯é€‚é…çš„å…·ä½“å®ç°ï¼Œä¸ºå¼€å‘å›¢é˜Ÿæä¾›äº†å®Œæ•´çš„äº¤äº’å®ç°æŒ‡å¯¼ã€‚*