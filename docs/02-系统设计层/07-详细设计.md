# Junmo Platform è¯¦ç»†è®¾è®¡æ–‡æ¡£

## ğŸ“‹ æ–‡æ¡£ä¿¡æ¯

| é¡¹ç›® | å†…å®¹ |
|------|------|
| **æ–‡æ¡£åç§°** | Junmo Platform è¯¦ç»†è®¾è®¡ |
| **ç‰ˆæœ¬å·** | v1.0.0 |
| **åˆ›å»ºæ—¥æœŸ** | 2025-12-24 |
| **ä½œè€…** | ç³»ç»Ÿæ¶æ„å¸ˆ |
| **å®¡æ ¸äºº** | æŠ€æœ¯æ¶æ„å¸ˆ |
| **æ‰¹å‡†äºº** | æŠ€æœ¯æ€»ç›‘ |

## ğŸ¯ è®¾è®¡æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›äº†Junmo Platformä¼ä¸šçº§æ™ºèƒ½ç®¡ç†å¹³å°çš„è¯¦ç»†è®¾è®¡ï¼ŒåŒ…æ‹¬å„ä¸ªæ¨¡å—çš„è¯¦ç»†å®ç°ã€æ¥å£å®šä¹‰ã€æ•°æ®æ¨¡å‹ã€ç®—æ³•è®¾è®¡ç­‰ã€‚æœ¬æ–‡æ¡£æ˜¯å¼€å‘äººå‘˜å®ç°ç³»ç»Ÿçš„ç›´æ¥æŒ‡å¯¼æ–‡æ¡£ã€‚

## ğŸ‘¥ ç”¨æˆ·æƒé™ç®¡ç†æ¨¡å—è¯¦ç»†è®¾è®¡

### 1. å®ä½“è®¾è®¡

#### Userå®ä½“
```java
@Entity
@Table(name = "users")
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class User extends BaseEntity {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(unique = true, nullable = false, length = 50)
    private String username;
    
    @Column(unique = true, nullable = false, length = 100)
    private String email;
    
    @Column(nullable = false)
    private String password;
    
    @Column(name = "first_name", length = 50)
    private String firstName;
    
    @Column(name = "last_name", length = 50)
    private String lastName;
    
    @Column(name = "phone_number", length = 20)
    private String phoneNumber;
    
    @Column(name = "avatar_url", length = 255)
    private String avatarUrl;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private UserStatus status;
    
    @Column(name = "last_login_time")
    private LocalDateTime lastLoginTime;
    
    @Column(name = "last_login_ip", length = 45)
    private String lastLoginIp;
    
    @Column(name = "login_count", columnDefinition = "int default 0")
    private Integer loginCount;
    
    @Column(name = "email_verified", columnDefinition = "boolean default false")
    private Boolean emailVerified;
    
    @Column(name = "phone_verified", columnDefinition = "boolean default false")
    private Boolean phoneVerified;
    
    @Column(name = "tenant_id")
    private Long tenantId;
    
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private Set<UserRole> userRoles = new HashSet<>();
    
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<UserSession> userSessions = new ArrayList<>();
    
    // æ„é€ å‡½æ•°
    public User() {
        this.status = UserStatus.ACTIVE;
        this.loginCount = 0;
        this.emailVerified = false;
        this.phoneVerified = false;
    }
    
    // é™æ€å·¥å‚æ–¹æ³•
    public static User create(String username, String email, String password) {
        User user = new User();
        user.username = username;
        user.email = email;
        user.password = password;
        user.status = UserStatus.ACTIVE;
        user.loginCount = 0;
        user.emailVerified = false;
        user.phoneVerified = false;
        return user;
    }
    
    // ä¸šåŠ¡æ–¹æ³•
    public void activate() {
        if (this.status == UserStatus.INACTIVE) {
            this.status = UserStatus.ACTIVE;
            DomainEventPublisher.publish(new UserActivatedEvent(this.id));
        }
    }
    
    public void deactivate() {
        if (this.status == UserStatus.ACTIVE) {
            this.status = UserStatus.INACTIVE;
            DomainEventPublisher.publish(new UserDeactivatedEvent(this.id));
        }
    }
    
    public void lock() {
        if (this.status != UserStatus.LOCKED) {
            this.status = UserStatus.LOCKED;
            DomainEventPublisher.publish(new UserLockedEvent(this.id));
        }
    }
    
    public void updateLoginInfo(String ipAddress) {
        this.lastLoginTime = LocalDateTime.now();
        this.lastLoginIp = ipAddress;
        this.loginCount = (this.loginCount == null ? 0 : this.loginCount) + 1;
    }
    
    public void verifyEmail() {
        this.emailVerified = true;
        DomainEventPublisher.publish(new UserEmailVerifiedEvent(this.id));
    }
    
    public void verifyPhone() {
        this.phoneVerified = true;
        DomainEventPublisher.publish(new UserPhoneVerifiedEvent(this.id));
    }
    
    public boolean isActive() {
        return UserStatus.ACTIVE.equals(this.status);
    }
    
    public boolean isLocked() {
        return UserStatus.LOCKED.equals(this.status);
    }
    
    public boolean hasRole(String roleName) {
        return userRoles.stream()
            .anyMatch(ur -> ur.getRole().getName().equals(roleName));
    }
    
    public Set<String> getRoleNames() {
        return userRoles.stream()
            .map(ur -> ur.getRole().getName())
            .collect(Collectors.toSet());
    }
    
    public Set<String> getPermissions() {
        return userRoles.stream()
            .flatMap(ur -> ur.getRole().getRolePermissions().stream())
            .map(rp -> rp.getPermission().getName())
            .collect(Collectors.toSet());
    }
    
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
    
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    
    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }
    
    public String getFirstName() { return firstName; }
    public void setFirstName(String firstName) { this.firstName = firstName; }
    
    public String getLastName() { return lastName; }
    public void setLastName(String lastName) { this.lastName = lastName; }
    
    public String getPhoneNumber() { return phoneNumber; }
    public void setPhoneNumber(String phoneNumber) { this.phoneNumber = phoneNumber; }
    
    public String getAvatarUrl() { return avatarUrl; }
    public void setAvatarUrl(String avatarUrl) { this.avatarUrl = avatarUrl; }
    
    public UserStatus getStatus() { return status; }
    public void setStatus(UserStatus status) { this.status = status; }
    
    public LocalDateTime getLastLoginTime() { return lastLoginTime; }
    public void setLastLoginTime(LocalDateTime lastLoginTime) { this.lastLoginTime = lastLoginTime; }
    
    public String getLastLoginIp() { return lastLoginIp; }
    public void setLastLoginIp(String lastLoginIp) { this.lastLoginIp = lastLoginIp; }
    
    public Integer getLoginCount() { return loginCount; }
    public void setLoginCount(Integer loginCount) { this.loginCount = loginCount; }
    
    public Boolean getEmailVerified() { return emailVerified; }
    public void setEmailVerified(Boolean emailVerified) { this.emailVerified = emailVerified; }
    
    public Boolean getPhoneVerified() { return phoneVerified; }
    public void setPhoneVerified(Boolean phoneVerified) { this.phoneVerified = phoneVerified; }
    
    public Long getTenantId() { return tenantId; }
    public void setTenantId(Long tenantId) { this.tenantId = tenantId; }
    
    public Set<UserRole> getUserRoles() { return userRoles; }
    public void setUserRoles(Set<UserRole> userRoles) { this.userRoles = userRoles; }
    
    public List<UserSession> getUserSessions() { return userSessions; }
    public void setUserSessions(List<UserSession> userSessions) { this.userSessions = userSessions; }
}
```

#### Roleå®ä½“
```java
@Entity
@Table(name = "roles")
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class Role extends BaseEntity {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(unique = true, nullable = false, length = 50)
    private String name;
    
    @Column(length = 100)
    private String description;
    
    @Column(name = "role_type")
    @Enumerated(EnumType.STRING)
    private RoleType roleType;
    
    @Column(name = "is_system", columnDefinition = "boolean default false")
    private Boolean isSystem;
    
    @Column(name = "sort_order")
    private Integer sortOrder;
    
    @Column(nullable = false)
    @Enumerated(EnumType.STRING)
    private Status status;
    
    @OneToMany(mappedBy = "role", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private Set<UserRole> userRoles = new HashSet<>();
    
    @OneToMany(mappedBy = "role", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private Set<RolePermission> rolePermissions = new HashSet<>();
    
    // æ„é€ å‡½æ•°
    public Role() {
        this.status = Status.ACTIVE;
        this.isSystem = false;
        this.sortOrder = 0;
    }
    
    public static Role create(String name, String description, RoleType roleType) {
        Role role = new Role();
        role.name = name;
        role.description = description;
        role.roleType = roleType;
        role.status = Status.ACTIVE;
        role.isSystem = false;
        role.sortOrder = 0;
        return role;
    }
    
    public static Role createSystemRole(String name, String description, RoleType roleType) {
        Role role = create(name, description, roleType);
        role.isSystem = true;
        return role;
    }
    
    // ä¸šåŠ¡æ–¹æ³•
    public void activate() {
        if (this.status != Status.ACTIVE) {
            this.status = Status.ACTIVE;
            DomainEventPublisher.publish(new RoleActivatedEvent(this.id));
        }
    }
    
    public void deactivate() {
        if (this.status == Status.ACTIVE && !this.isSystem) {
            this.status = Status.INACTIVE;
            DomainEventPublisher.publish(new RoleDeactivatedEvent(this.id));
        }
    }
    
    public void addPermission(Permission permission) {
        RolePermission rolePermission = new RolePermission(this, permission);
        this.rolePermissions.add(rolePermission);
    }
    
    public void removePermission(Permission permission) {
        this.rolePermissions.removeIf(rp -> rp.getPermission().equals(permission));
    }
    
    public boolean hasPermission(String permissionName) {
        return rolePermissions.stream()
            .anyMatch(rp -> rp.getPermission().getName().equals(permissionName));
    }
    
    public Set<String> getPermissionNames() {
        return rolePermissions.stream()
            .map(rp -> rp.getPermission().getName())
            .collect(Collectors.toSet());
    }
    
    public boolean isSystemRole() {
        return Boolean.TRUE.equals(this.isSystem);
    }
    
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    
    public RoleType getRoleType() { return roleType; }
    public void setRoleType(RoleType roleType) { this.roleType = roleType; }
    
    public Boolean getIsSystem() { return isSystem; }
    public void setIsSystem(Boolean isSystem) { this.isSystem = isSystem; }
    
    public Integer getSortOrder() { return sortOrder; }
    public void setSortOrder(Integer sortOrder) { this.sortOrder = sortOrder; }
    
    public Status getStatus() { return status; }
    public void setStatus(Status status) { this.status = status; }
    
    public Set<UserRole> getUserRoles() { return userRoles; }
    public void setUserRoles(Set<UserRole> userRoles) { this.userRoles = userRoles; }
    
    public Set<RolePermission> getRolePermissions() { return rolePermissions; }
    public void setRolePermissions(Set<RolePermission> rolePermissions) { this.rolePermissions = rolePermissions; }
}
```

### 2. æœåŠ¡å±‚è®¾è®¡

#### UserDomainService
```java
@Service
@Transactional
public class UserDomainService {
    
    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    private final PasswordEncoder passwordEncoder;
    private final ValidationService validationService;
    
    public UserDomainService(UserRepository userRepository, 
                           RoleRepository roleRepository,
                           PasswordEncoder passwordEncoder,
                           ValidationService validationService) {
        this.userRepository = userRepository;
        this.roleRepository = roleRepository;
        this.passwordEncoder = passwordEncoder;
        this.validationService = validationService;
    }
    
    /**
     * åˆ›å»ºç”¨æˆ·
     */
    public User createUser(CreateUserCommand command) {
        // 1. éªŒè¯è¾“å…¥
        validationService.validate(command);
        
        // 2. æ£€æŸ¥ç”¨æˆ·åå”¯ä¸€æ€§
        if (userRepository.existsByUsername(command.getUsername())) {
            throw new UserAlreadyExistsException("Username already exists: " + command.getUsername());
        }
        
        // 3. æ£€æŸ¥é‚®ç®±å”¯ä¸€æ€§
        if (userRepository.existsByEmail(command.getEmail())) {
            throw new UserAlreadyExistsException("Email already exists: " + command.getEmail());
        }
        
        // 4. éªŒè¯å¯†ç å¼ºåº¦
        if (!isPasswordStrong(command.getPassword())) {
            throw new WeakPasswordException("Password does not meet security requirements");
        }
        
        // 5. åŠ å¯†å¯†ç 
        String encodedPassword = passwordEncoder.encode(command.getPassword());
        
        // 6. åˆ›å»ºç”¨æˆ·å®ä½“
        User user = User.create(command.getUsername(), command.getEmail(), encodedPassword);
        user.setFirstName(command.getFirstName());
        user.setLastName(command.getLastName());
        user.setPhoneNumber(command.getPhoneNumber());
        user.setTenantId(command.getTenantId());
        
        // 7. åˆ†é…é»˜è®¤è§’è‰²
        assignDefaultRoles(user, command.getTenantId());
        
        // 8. ä¿å­˜ç”¨æˆ·
        User savedUser = userRepository.save(user);
        
        // 9. å‘å¸ƒäº‹ä»¶
        DomainEventPublisher.publish(new UserCreatedEvent(savedUser.getId()));
        
        return savedUser;
    }
    
    /**
     * æ›´æ–°ç”¨æˆ·ä¿¡æ¯
     */
    public User updateUser(UpdateUserCommand command) {
        // 1. è·å–ç”¨æˆ·
        User user = userRepository.findById(command.getUserId())
            .orElseThrow(() -> new UserNotFoundException("User not found: " + command.getUserId()));
        
        // 2. æ£€æŸ¥é‚®ç®±å”¯ä¸€æ€§ï¼ˆå¦‚æœé‚®ç®±å‘ç”Ÿå˜åŒ–ï¼‰
        if (!user.getEmail().equals(command.getEmail()) && 
            userRepository.existsByEmail(command.getEmail())) {
            throw new UserAlreadyExistsException("Email already exists: " + command.getEmail());
        }
        
        // 3. æ›´æ–°ç”¨æˆ·ä¿¡æ¯
        user.setEmail(command.getEmail());
        user.setFirstName(command.getFirstName());
        user.setLastName(command.getLastName());
        user.setPhoneNumber(command.getPhoneNumber());
        user.setAvatarUrl(command.getAvatarUrl());
        
        // 4. ä¿å­˜æ›´æ–°
        User updatedUser = userRepository.save(user);
        
        // 5. å‘å¸ƒäº‹ä»¶
        DomainEventPublisher.publish(new UserUpdatedEvent(updatedUser.getId()));
        
        return updatedUser;
    }
    
    /**
     * ç”¨æˆ·ç™»å½•
     */
    public UserLoginResult login(LoginCommand command) {
        // 1. è·å–ç”¨æˆ·
        User user = userRepository.findByUsername(command.getUsername())
            .orElseThrow(() -> new AuthenticationException("Invalid username or password"));
        
        // 2. æ£€æŸ¥ç”¨æˆ·çŠ¶æ€
        if (!user.isActive()) {
            throw new UserLockedException("User account is not active");
        }
        
        if (user.isLocked()) {
            throw new UserLockedException("User account is locked");
        }
        
        // 3. éªŒè¯å¯†ç 
        if (!passwordEncoder.matches(command.getPassword(), user.getPassword())) {
            handleFailedLogin(user);
            throw new AuthenticationException("Invalid username or password");
        }
        
        // 4. æ›´æ–°ç™»å½•ä¿¡æ¯
        user.updateLoginInfo(command.getIpAddress());
        userRepository.save(user);
        
        // 5. ç”ŸæˆJWT Token
        String token = generateJwtToken(user);
        
        // 6. åˆ›å»ºç”¨æˆ·ä¼šè¯
        UserSession session = createUserSession(user, command.getIpAddress(), command.getUserAgent());
        
        // 7. å‘å¸ƒäº‹ä»¶
        DomainEventPublisher.publish(new UserLoggedInEvent(user.getId()));
        
        return UserLoginResult.builder()
            .user(UserMapper.toDTO(user))
            .token(token)
            .sessionId(session.getId())
            .expiresIn(getTokenExpiration())
            .build();
    }
    
    /**
     * åˆ†é…è§’è‰²
     */
    public void assignRoles(Long userId, Set<Long> roleIds) {
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new UserNotFoundException("User not found: " + userId));
        
        // æ¸…é™¤ç°æœ‰è§’è‰²
        user.getUserRoles().clear();
        
        // åˆ†é…æ–°è§’è‰²
        for (Long roleId : roleIds) {
            Role role = roleRepository.findById(roleId)
                .orElseThrow(() -> new RoleNotFoundException("Role not found: " + roleId));
            
            if (role.getStatus() != Status.ACTIVE) {
                throw new RoleInactiveException("Role is not active: " + role.getName());
            }
            
            UserRole userRole = new UserRole(user, role);
            user.getUserRoles().add(userRole);
        }
        
        userRepository.save(user);
        
        // å‘å¸ƒäº‹ä»¶
        DomainEventPublisher.publish(new UserRolesUpdatedEvent(userId));
    }
    
    /**
     * ä¿®æ”¹å¯†ç 
     */
    public void changePassword(ChangePasswordCommand command) {
        User user = userRepository.findById(command.getUserId())
            .orElseThrow(() -> new UserNotFoundException("User not found: " + command.getUserId()));
        
        // éªŒè¯å½“å‰å¯†ç 
        if (!passwordEncoder.matches(command.getCurrentPassword(), user.getPassword())) {
            throw new InvalidPasswordException("Current password is incorrect");
        }
        
        // éªŒè¯æ–°å¯†ç å¼ºåº¦
        if (!isPasswordStrong(command.getNewPassword())) {
            throw new WeakPasswordException("New password does not meet security requirements");
        }
        
        // æ›´æ–°å¯†ç 
        String encodedPassword = passwordEncoder.encode(command.getNewPassword());
        user.setPassword(encodedPassword);
        
        userRepository.save(user);
        
        // å‘å¸ƒäº‹ä»¶
        DomainEventPublisher.publish(new UserPasswordChangedEvent(user.getId()));
    }
    
    /**
     * é‡ç½®å¯†ç 
     */
    public void resetPassword(ResetPasswordCommand command) {
        User user = userRepository.findByEmail(command.getEmail())
            .orElseThrow(() -> new UserNotFoundException("User not found with email: " + command.getEmail()));
        
        // ç”Ÿæˆä¸´æ—¶å¯†ç 
        String tempPassword = generateTempPassword();
        String encodedPassword = passwordEncoder.encode(tempPassword);
        
        // æ›´æ–°å¯†ç 
        user.setPassword(encodedPassword);
        user.setStatus(UserStatus.REQUIRES_PASSWORD_CHANGE);
        
        userRepository.save(user);
        
        // å‘é€é‡ç½®å¯†ç é‚®ä»¶
        DomainEventPublisher.publish(new PasswordResetEvent(user.getId(), tempPassword));
    }
    
    // ç§æœ‰æ–¹æ³•
    private void assignDefaultRoles(User user, Long tenantId) {
        // æ ¹æ®ç§Ÿæˆ·IDåˆ†é…é»˜è®¤è§’è‰²
        List<Role> defaultRoles = roleRepository.findByRoleTypeAndStatus(RoleType.DEFAULT, Status.ACTIVE);
        
        for (Role role : defaultRoles) {
            UserRole userRole = new UserRole(user, role);
            user.getUserRoles().add(userRole);
        }
    }
    
    private boolean isPasswordStrong(String password) {
        // å¯†ç å¼ºåº¦éªŒè¯é€»è¾‘
        return password != null && 
               password.length() >= 8 && 
               password.matches(".*[A-Z].*") && 
               password.matches(".*[a-z].*") && 
               password.matches(".*[0-9].*") && 
               password.matches(".*[!@#$%^&*].*");
    }
    
    private void handleFailedLogin(User user) {
        // è®°å½•å¤±è´¥ç™»å½•æ¬¡æ•°
        // å¦‚æœå¤±è´¥æ¬¡æ•°è¶…è¿‡é˜ˆå€¼ï¼Œé”å®šè´¦æˆ·
        // è¿™é‡Œå¯ä»¥å®ç°å…·ä½“çš„å¤±è´¥ç™»å½•å¤„ç†é€»è¾‘
    }
    
    private String generateJwtToken(User user) {
        // JWT Tokenç”Ÿæˆé€»è¾‘
        return JwtTokenGenerator.generate(user);
    }
    
    private UserSession createUserSession(User user, String ipAddress, String userAgent) {
        UserSession session = new UserSession();
        session.setUser(user);
        session.setIpAddress(ipAddress);
        session.setUserAgent(userAgent);
        session.setCreatedAt(LocalDateTime.now());
        session.setExpiresAt(LocalDateTime.now().plusHours(24));
        session.setStatus(SessionStatus.ACTIVE);
        
        return userSessionRepository.save(session);
    }
    
    private long getTokenExpiration() {
        return 3600; // 1å°æ—¶
    }
    
    private String generateTempPassword() {
        // ç”Ÿæˆä¸´æ—¶å¯†ç é€»è¾‘
        return UUID.randomUUID().toString().substring(0, 8);
    }
}
```

### 3. æ§åˆ¶å™¨è®¾è®¡

#### UserController
```java
@RestController
@RequestMapping("/api/v1/users")
@Validated
@Slf4j
public class UserController {
    
    private final UserApplicationService userApplicationService;
    private final UserQueryService userQueryService;
    
    public UserController(UserApplicationService userApplicationService,
                        UserQueryService userQueryService) {
        this.userApplicationService = userApplicationService;
        this.userQueryService = userQueryService;
    }
    
    /**
     * åˆ›å»ºç”¨æˆ·
     */
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<ApiResponse<UserDTO>> createUser(
            @Valid @RequestBody CreateUserRequest request) {
        
        log.info("Creating user with username: {}", request.getUsername());
        
        CreateUserCommand command = UserMapper.toCreateCommand(request);
        User user = userApplicationService.createUser(command);
        UserDTO userDTO = UserMapper.toDTO(user);
        
        return ResponseEntity.status(HttpStatus.CREATED)
            .body(ApiResponse.success(userDTO));
    }
    
    /**
     * è·å–ç”¨æˆ·åˆ—è¡¨
     */
    @GetMapping
    @PreAuthorize("hasRole('USER')")
    public ResponseEntity<ApiResponse<PageResponse<UserDTO>>> getUsers(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(required = false) String keyword,
            @RequestParam(required = false) UserStatus status,
            @RequestParam(required = false) Long roleId) {
        
        log.info("Getting users with page: {}, size: {}, keyword: {}, status: {}, roleId: {}", 
                page, size, keyword, status, roleId);
        
        UserQuery query = UserQuery.builder()
            .page(page)
            .size(size)
            .keyword(keyword)
            .status(status)
            .roleId(roleId)
            .build();
        
        Page<UserDTO> users = userQueryService.findUsers(query);
        PageResponse<UserDTO> response = PageMapper.toResponse(users);
        
        return ResponseEntity.ok(ApiResponse.success(response));
    }
    
    /**
     * è·å–ç”¨æˆ·è¯¦æƒ…
     */
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('USER')")
    public ResponseEntity<ApiResponse<UserDTO>> getUser(@PathVariable Long id) {
        log.info("Getting user with id: {}", id);
        
        User user = userQueryService.findUserById(id);
        UserDTO userDTO = UserMapper.toDTO(user);
        
        return ResponseEntity.ok(ApiResponse.success(userDTO));
    }
    
    /**
     * æ›´æ–°ç”¨æˆ·
     */
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or #id == authentication.principal.id")
    public ResponseEntity<ApiResponse<UserDTO>> updateUser(
            @PathVariable Long id,
            @Valid @RequestBody UpdateUserRequest request) {
        
        log.info("Updating user with id: {}", id);
        
        UpdateUserCommand command = UserMapper.toUpdateCommand(id, request);
        User user = userApplicationService.updateUser(command);
        UserDTO userDTO = UserMapper.toDTO(user);
        
        return ResponseEntity.ok(ApiResponse.success(userDTO));
    }
    
    /**
     * åˆ é™¤ç”¨æˆ·
     */
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<ApiResponse<Void>> deleteUser(@PathVariable Long id) {
        log.info("Deleting user with id: {}", id);
        
        userApplicationService.deleteUser(id);
        
        return ResponseEntity.noContent().build();
    }
    
    /**
     * ä¿®æ”¹å¯†ç 
     */
    @PutMapping("/{id}/password")
    @PreAuthorize("hasRole('USER') and #id == authentication.principal.id")
    public ResponseEntity<ApiResponse<Void>> changePassword(
            @PathVariable Long id,
            @Valid @RequestBody ChangePasswordRequest request) {
        
        log.info("Changing password for user with id: {}", id);
        
        ChangePasswordCommand command = UserMapper.toChangePasswordCommand(id, request);
        userApplicationService.changePassword(command);
        
        return ResponseEntity.ok(ApiResponse.success());
    }
    
    /**
     * é‡ç½®å¯†ç 
     */
    @PostMapping("/{id}/reset-password")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<ApiResponse<Void>> resetPassword(@PathVariable Long id) {
        log.info("Resetting password for user with id: {}", id);
        
        userApplicationService.resetPassword(id);
        
        return ResponseEntity.ok(ApiResponse.success());
    }
    
    /**
     * åˆ†é…è§’è‰²
     */
    @PutMapping("/{id}/roles")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<ApiResponse<Void>> assignRoles(
            @PathVariable Long id,
            @Valid @RequestBody AssignRolesRequest request) {
        
        log.info("Assigning roles to user with id: {}", id);
        
        AssignRolesCommand command = UserMapper.toAssignRolesCommand(id, request);
        userApplicationService.assignRoles(command);
        
        return ResponseEntity.ok(ApiResponse.success());
    }
    
    /**
     * è·å–ç”¨æˆ·è§’è‰²
     */
    @GetMapping("/{id}/roles")
    @PreAuthorize("hasRole('USER')")
    public ResponseEntity<ApiResponse<List<RoleDTO>>> getUserRoles(@PathVariable Long id) {
        log.info("Getting roles for user with id: {}", id);
        
        List<Role> roles = userQueryService.findUserRoles(id);
        List<RoleDTO> roleDTOs = roles.stream()
            .map(RoleMapper::toDTO)
            .collect(Collectors.toList());
        
        return ResponseEntity.ok(ApiResponse.success(roleDTOs));
    }
    
    /**
     * æ¿€æ´»ç”¨æˆ·
     */
    @PutMapping("/{id}/activate")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<ApiResponse<Void>> activateUser(@PathVariable Long id) {
        log.info("Activating user with id: {}", id);
        
        userApplicationService.activateUser(id);
        
        return ResponseEntity.ok(ApiResponse.success());
    }
    
    /**
     * åœç”¨ç”¨æˆ·
     */
    @PutMapping("/{id}/deactivate")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<ApiResponse<Void>> deactivateUser(@PathVariable Long id) {
        log.info("Deactivating user with id: {}", id);
        
        userApplicationService.deactivateUser(id);
        
        return ResponseEntity.ok(ApiResponse.success());
    }
    
    /**
     * é”å®šç”¨æˆ·
     */
    @PutMapping("/{id}/lock")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<ApiResponse<Void>> lockUser(@PathVariable Long id) {
        log.info("Locking user with id: {}", id);
        
        userApplicationService.lockUser(id);
        
        return ResponseEntity.ok(ApiResponse.success());
    }
    
    /**
     * è§£é”ç”¨æˆ·
     */
    @PutMapping("/{id}/unlock")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<ApiResponse<Void>> unlockUser(@PathVariable Long id) {
        log.info("Unlocking user with id: {}", id);
        
        userApplicationService.unlockUser(id);
        
        return ResponseEntity.ok(ApiResponse.success());
    }
}
```

### 4. DTOè®¾è®¡

#### UserDTO
```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserDTO {
    
    private Long id;
    private String username;
    private String email;
    private String firstName;
    private String lastName;
    private String phoneNumber;
    private String avatarUrl;
    private UserStatus status;
    private LocalDateTime lastLoginTime;
    private String lastLoginIp;
    private Integer loginCount;
    private Boolean emailVerified;
    private Boolean phoneVerified;
    private Long tenantId;
    private Set<RoleDTO> roles;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private String createdBy;
    private String updatedBy;
    
    // è®¡ç®—å±æ€§
    public String getFullName() {
        if (firstName != null && lastName != null) {
            return firstName + " " + lastName;
        }
        return username;
    }
    
    public boolean isActive() {
        return UserStatus.ACTIVE.equals(status);
    }
    
    public boolean isEmailVerified() {
        return Boolean.TRUE.equals(emailVerified);
    }
    
    public boolean isPhoneVerified() {
        return Boolean.TRUE.equals(phoneVerified);
    }
}
```

#### CreateUserRequest
```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CreateUserRequest {
    
    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 50, message = "Username must be between 3 and 50 characters")
    @Pattern(regexp = "^[a-zA-Z0-9_]+$", message = "Username can only contain letters, numbers and underscores")
    private String username;
    
    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    @Size(max = 100, message = "Email must be less than 100 characters")
    private String email;
    
    @NotBlank(message = "Password is required")
    @Size(min = 8, max = 128, message = "Password must be between 8 and 128 characters")
    @Pattern(regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]", 
             message = "Password must contain at least one uppercase letter, one lowercase letter, one digit and one special character")
    private String password;
    
    @Size(max = 50, message = "First name must be less than 50 characters")
    private String firstName;
    
    @Size(max = 50, message = "Last name must be less than 50 characters")
    private String lastName;
    
    @Pattern(regexp = "^[+]?[1-9]\\d{1,14}$", message = "Invalid phone number format")
    private String phoneNumber;
    
    @URL(message = "Invalid avatar URL format")
    private String avatarUrl;
    
    private Set<Long> roleIds;
    
    private Long tenantId;
}
```

## ğŸ“„ å†…å®¹ç®¡ç†æ¨¡å—è¯¦ç»†è®¾è®¡

### 1. å®ä½“è®¾è®¡

#### Documentå®ä½“
```java
@Entity
@Table(name = "documents")
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class Document extends BaseEntity {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, length = 255)
    private String title;
    
    @Column(columnDefinition = "LONGTEXT")
    private String content;
    
    @Column(name = "summary", length = 500)
    private String summary;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id")
    private Category category;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "author_id", nullable = false)
    private User author;
    
    @Column(name = "document_type")
    @Enumerated(EnumType.STRING)
    private DocumentType documentType;
    
    @Column(nullable = false)
    @Enumerated(EnumType.STRING)
    private DocumentStatus status;
    
    @Column(name = "version", columnDefinition = "int default 1")
    private Integer version;
    
    @Column(name = "parent_id")
    private Long parentId;
    
    @Column(name = "sort_order")
    private Integer sortOrder;
    
    @Column(name = "view_count", columnDefinition = "int default 0")
    private Integer viewCount;
    
    @Column(name = "download_count", columnDefinition = "int default 0")
    private Integer downloadCount;
    
    @Column(name = "like_count", columnDefinition = "int default 0")
    private Integer likeCount;
    
    @Column(name = "is_public", columnDefinition = "boolean default false")
    private Boolean isPublic;
    
    @Column(name = "is_top", columnDefinition = "boolean default false")
    private Boolean isTop;
    
    @Column(name = "published_at")
    private LocalDateTime publishedAt;
    
    @Column(name = "expired_at")
    private LocalDateTime expiredAt;
    
    @Column(name = "file_path", length = 500)
    private String filePath;
    
    @Column(name = "file_size")
    private Long fileSize;
    
    @Column(name = "file_type", length = 50)
    private String fileType;
    
    @Column(name = "thumbnail_path", length = 500)
    private String thumbnailPath;
    
    @ManyToMany
    @JoinTable(
        name = "document_tags",
        joinColumns = @JoinColumn(name = "document_id"),
        inverseJoinColumns = @JoinColumn(name = "tag_id")
    )
    private Set<Tag> tags = new HashSet<>();
    
    @OneToMany(mappedBy = "document", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<DocumentVersion> versions = new ArrayList<>();
    
    @OneToMany(mappedBy = "document", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private Set<DocumentPermission> permissions = new HashSet<>();
    
    // æ„é€ å‡½æ•°
    public Document() {
        this.status = DocumentStatus.DRAFT;
        this.version = 1;
        this.viewCount = 0;
        this.downloadCount = 0;
        this.likeCount = 0;
        this.isPublic = false;
        this.isTop = false;
        this.sortOrder = 0;
    }
    
    public static Document create(String title, String content, User author) {
        Document document = new Document();
        document.title = title;
        document.content = content;
        document.author = author;
        document.status = DocumentStatus.DRAFT;
        document.version = 1;
        document.viewCount = 0;
        document.downloadCount = 0;
        document.likeCount = 0;
        document.isPublic = false;
        document.isTop = false;
        document.sortOrder = 0;
        return document;
    }
    
    // ä¸šåŠ¡æ–¹æ³•
    public void publish() {
        if (this.status == DocumentStatus.DRAFT) {
            this.status = DocumentStatus.PUBLISHED;
            this.publishedAt = LocalDateTime.now();
            DomainEventPublisher.publish(new DocumentPublishedEvent(this.id));
        }
    }
    
    public void archive() {
        if (this.status == DocumentStatus.PUBLISHED) {
            this.status = DocumentStatus.ARCHIVED;
            DomainEventPublisher.publish(new DocumentArchivedEvent(this.id));
        }
    }
    
    public void updateContent(String newContent, User updatedBy) {
        // åˆ›å»ºç‰ˆæœ¬è®°å½•
        DocumentVersion version = DocumentVersion.create(this, updatedBy);
        this.versions.add(version);
        
        // æ›´æ–°å†…å®¹
        this.content = newContent;
        this.version = this.version + 1;
        
        DomainEventPublisher.publish(new DocumentUpdatedEvent(this.id));
    }
    
    public void incrementViewCount() {
        this.viewCount = (this.viewCount == null ? 0 : this.viewCount) + 1;
    }
    
    public void incrementDownloadCount() {
        this.downloadCount = (this.downloadCount == null ? 0 : this.downloadCount) + 1;
    }
    
    public void incrementLikeCount() {
        this.likeCount = (this.likeCount == null ? 0 : this.likeCount) + 1;
    }
    
    public void decrementLikeCount() {
        this.likeCount = (this.likeCount == null ? 0 : this.likeCount) - 1;
        if (this.likeCount < 0) {
            this.likeCount = 0;
        }
    }
    
    public void addTag(Tag tag) {
        this.tags.add(tag);
    }
    
    public void removeTag(Tag tag) {
        this.tags.remove(tag);
    }
    
    public boolean hasTag(String tagName) {
        return tags.stream()
            .anyMatch(tag -> tag.getName().equals(tagName));
    }
    
    public boolean isPublished() {
        return DocumentStatus.PUBLISHED.equals(this.status);
    }
    
    public boolean isDraft() {
        return DocumentStatus.DRAFT.equals(this.status);
    }
    
    public boolean isArchived() {
        return DocumentStatus.ARCHIVED.equals(this.status);
    }
    
    public boolean isExpired() {
        return this.expiredAt != null && this.expiredAt.isBefore(LocalDateTime.now());
    }
    
    public boolean canView(User user) {
        // æ£€æŸ¥æŸ¥çœ‹æƒé™
        if (Boolean.TRUE.equals(this.isPublic)) {
            return true;
        }
        
        if (user != null && user.equals(this.author)) {
            return true;
        }
        
        return hasPermission(user, PermissionType.VIEW);
    }
    
    public boolean canEdit(User user) {
        // æ£€æŸ¥ç¼–è¾‘æƒé™
        if (user != null && user.equals(this.author)) {
            return true;
        }
        
        return hasPermission(user, PermissionType.EDIT);
    }
    
    public boolean canDelete(User user) {
        // æ£€æŸ¥åˆ é™¤æƒé™
        if (user != null && user.equals(this.author)) {
            return true;
        }
        
        return hasPermission(user, PermissionType.DELETE);
    }
    
    private boolean hasPermission(User user, PermissionType permissionType) {
        return permissions.stream()
            .anyMatch(dp -> dp.getUser().equals(user) && 
                        dp.getPermissionType().equals(permissionType));
    }
    
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getTitle() { return title; }
    public void setTitle(String title) { this.title = title; }
    
    public String getContent() { return content; }
    public void setContent(String content) { this.content = content; }
    
    public String getSummary() { return summary; }
    public void setSummary(String summary) { this.summary = summary; }
    
    public Category getCategory() { return category; }
    public void setCategory(Category category) { this.category = category; }
    
    public User getAuthor() { return author; }
    public void setAuthor(User author) { this.author = author; }
    
    public DocumentType getDocumentType() { return documentType; }
    public void setDocumentType(DocumentType documentType) { this.documentType = documentType; }
    
    public DocumentStatus getStatus() { return status; }
    public void setStatus(DocumentStatus status) { this.status = status; }
    
    public Integer getVersion() { return version; }
    public void setVersion(Integer version) { this.version = version; }
    
    public Long getParentId() { return parentId; }
    public void setParentId(Long parentId) { this.parentId = parentId; }
    
    public Integer getSortOrder() { return sortOrder; }
    public void setSortOrder(Integer sortOrder) { this.sortOrder = sortOrder; }
    
    public Integer getViewCount() { return viewCount; }
    public void setViewCount(Integer viewCount) { this.viewCount = viewCount; }
    
    public Integer getDownloadCount() { return downloadCount; }
    public void setDownloadCount(Integer downloadCount) { this.downloadCount = downloadCount; }
    
    public Integer getLikeCount() { return likeCount; }
    public void setLikeCount(Integer likeCount) { this.likeCount = likeCount; }
    
    public Boolean getIsPublic() { return isPublic; }
    public void setIsPublic(Boolean isPublic) { this.isPublic = isPublic; }
    
    public Boolean getIsTop() { return isTop; }
    public void setIsTop(Boolean isTop) { this.isTop = isTop; }
    
    public LocalDateTime getPublishedAt() { return publishedAt; }
    public void setPublishedAt(LocalDateTime publishedAt) { this.publishedAt = publishedAt; }
    
    public LocalDateTime getExpiredAt() { return expiredAt; }
    public void setExpiredAt(LocalDateTime expiredAt) { this.expiredAt = expiredAt; }
    
    public String getFilePath() { return filePath; }
    public void setFilePath(String filePath) { this.filePath = filePath; }
    
    public Long getFileSize() { return fileSize; }
    public void setFileSize(Long fileSize) { this.fileSize = fileSize; }
    
    public String getFileType() { return fileType; }
    public void setFileType(String fileType) { this.fileType = fileType; }
    
    public String getThumbnailPath() { return thumbnailPath; }
    public void setThumbnailPath(String thumbnailPath) { this.thumbnailPath = thumbnailPath; }
    
    public Set<Tag> getTags() { return tags; }
    public void setTags(Set<Tag> tags) { this.tags = tags; }
    
    public List<DocumentVersion> getVersions() { return versions; }
    public void setVersions(List<DocumentVersion> versions) { this.versions = versions; }
    
    public Set<DocumentPermission> getPermissions() { return permissions; }
    public void setPermissions(Set<DocumentPermission> permissions) { this.permissions = permissions; }
}
```

### 2. æœåŠ¡å±‚è®¾è®¡

#### DocumentDomainService
```java
@Service
@Transactional
public class DocumentDomainService {
    
    private final DocumentRepository documentRepository;
    private final CategoryRepository categoryRepository;
    private final TagRepository tagRepository;
    private final UserRepository userRepository;
    private final SearchService searchService;
    private final FileStorageService fileStorageService;
    private final ValidationService validationService;
    
    public DocumentDomainService(DocumentRepository documentRepository,
                                CategoryRepository categoryRepository,
                                TagRepository tagRepository,
                                UserRepository userRepository,
                                SearchService searchService,
                                FileStorageService fileStorageService,
                                ValidationService validationService) {
        this.documentRepository = documentRepository;
        this.categoryRepository = categoryRepository;
        this.tagRepository = tagRepository;
        this.userRepository = userRepository;
        this.searchService = searchService;
        this.fileStorageService = fileStorageService;
        this.validationService = validationService;
    }
    
    /**
     * åˆ›å»ºæ–‡æ¡£
     */
    public Document createDocument(CreateDocumentCommand command) {
        // 1. éªŒè¯è¾“å…¥
        validationService.validate(command);
        
        // 2. è·å–ä½œè€…
        User author = userRepository.findById(command.getAuthorId())
            .orElseThrow(() -> new UserNotFoundException("Author not found: " + command.getAuthorId()));
        
        // 3. è·å–åˆ†ç±»
        Category category = null;
        if (command.getCategoryId() != null) {
            category = categoryRepository.findById(command.getCategoryId())
                .orElseThrow(() -> new CategoryNotFoundException("Category not found: " + command.getCategoryId()));
        }
        
        // 4. åˆ›å»ºæ–‡æ¡£å®ä½“
        Document document = Document.create(command.getTitle(), command.getContent(), author);
        document.setSummary(command.getSummary());
        document.setCategory(category);
        document.setDocumentType(command.getDocumentType());
        document.setParentId(command.getParentId());
        document.setIsPublic(command.getIsPublic());
        document.setExpiredAt(command.getExpiredAt());
        
        // 5. å¤„ç†æ–‡ä»¶ä¸Šä¼ 
        if (command.getFile() != null) {
            handleFileUpload(document, command.getFile());
        }
        
        // 6. å¤„ç†æ ‡ç­¾
        handleTags(document, command.getTagIds());
        
        // 7. ä¿å­˜æ–‡æ¡£
        Document savedDocument = documentRepository.save(document);
        
        // 8. ç´¢å¼•åˆ°æœç´¢å¼•æ“
        searchService.indexDocument(savedDocument);
        
        // 9. å‘å¸ƒäº‹ä»¶
        DomainEventPublisher.publish(new DocumentCreatedEvent(savedDocument.getId()));
        
        return savedDocument;
    }
    
    /**
     * æ›´æ–°æ–‡æ¡£
     */
    public Document updateDocument(UpdateDocumentCommand command) {
        // 1. è·å–æ–‡æ¡£
        Document document = documentRepository.findById(command.getDocumentId())
            .orElseThrow(() -> new DocumentNotFoundException("Document not found: " + command.getDocumentId()));
        
        // 2. æ£€æŸ¥æƒé™
        if (!document.canEdit(command.getUpdater())) {
            throw new DocumentPermissionDeniedException("No permission to edit document");
        }
        
        // 3. æ›´æ–°åŸºæœ¬ä¿¡æ¯
        document.setTitle(command.getTitle());
        document.setSummary(command.getSummary());
        document.setCategory(command.getCategory());
        document.setDocumentType(command.getDocumentType());
        document.setIsPublic(command.getIsPublic());
        document.setExpiredAt(command.getExpiredAt());
        
        // 4. æ›´æ–°å†…å®¹ï¼ˆåˆ›å»ºç‰ˆæœ¬ï¼‰
        if (!Objects.equals(document.getContent(), command.getContent())) {
            document.updateContent(command.getContent(), command.getUpdater());
        }
        
        // 5. å¤„ç†æ ‡ç­¾æ›´æ–°
        handleTags(document, command.getTagIds());
        
        // 6. ä¿å­˜æ›´æ–°
        Document updatedDocument = documentRepository.save(document);
        
        // 7. æ›´æ–°æœç´¢ç´¢å¼•
        searchService.updateDocument(updatedDocument);
        
        // 8. å‘å¸ƒäº‹ä»¶
        DomainEventPublisher.publish(new DocumentUpdatedEvent(updatedDocument.getId()));
        
        return updatedDocument;
    }
    
    /**
     * å‘å¸ƒæ–‡æ¡£
     */
    public void publishDocument(Long documentId, User publisher) {
        Document document = documentRepository.findById(documentId)
            .orElseThrow(() -> new DocumentNotFoundException("Document not found: " + documentId));
        
        if (!document.canEdit(publisher)) {
            throw new DocumentPermissionDeniedException("No permission to publish document");
        }
        
        if (document.isExpired()) {
            throw new DocumentExpiredException("Document has expired");
        }
        
        document.publish();
        documentRepository.save(document);
        
        // æ›´æ–°æœç´¢ç´¢å¼•
        searchService.updateDocument(document);
        
        // å‘å¸ƒäº‹ä»¶
        DomainEventPublisher.publish(new DocumentPublishedEvent(documentId));
    }
    
    /**
     * åˆ é™¤æ–‡æ¡£
     */
    public void deleteDocument(Long documentId, User deleter) {
        Document document = documentRepository.findById(documentId)
            .orElseThrow(() -> new DocumentNotFoundException("Document not found: " + documentId));
        
        if (!document.canDelete(deleter)) {
            throw new DocumentPermissionDeniedException("No permission to delete document");
        }
        
        // åˆ é™¤æ–‡ä»¶
        if (document.getFilePath() != null) {
            fileStorageService.deleteFile(document.getFilePath());
        }
        
        // åˆ é™¤ç¼©ç•¥å›¾
        if (document.getThumbnailPath() != null) {
            fileStorageService.deleteFile(document.getThumbnailPath());
        }
        
        // ä»æœç´¢å¼•æ“åˆ é™¤
        searchService.deleteDocument(documentId);
        
        // åˆ é™¤æ–‡æ¡£
        documentRepository.delete(document);
        
        // å‘å¸ƒäº‹ä»¶
        DomainEventPublisher.publish(new DocumentDeletedEvent(documentId));
    }
    
    /**
     * æŸ¥çœ‹æ–‡æ¡£
     */
    public Document viewDocument(Long documentId, User viewer) {
        Document document = documentRepository.findById(documentId)
            .orElseThrow(() -> new DocumentNotFoundException("Document not found: " + documentId));
        
        if (!document.canView(viewer)) {
            throw new DocumentPermissionDeniedException("No permission to view document");
        }
        
        if (document.isExpired()) {
            throw new DocumentExpiredException("Document has expired");
        }
        
        // å¢åŠ æŸ¥çœ‹æ¬¡æ•°
        document.incrementViewCount();
        documentRepository.save(document);
        
        // å‘å¸ƒäº‹ä»¶
        DomainEventPublisher.publish(new DocumentViewedEvent(documentId, viewer.getId()));
        
        return document;
    }
    
    /**
     * ç‚¹èµæ–‡æ¡£
     */
    public void likeDocument(Long documentId, User user) {
        Document document = documentRepository.findById(documentId)
            .orElseThrow(() -> new DocumentNotFoundException("Document not found: " + documentId));
        
        if (!document.canView(user)) {
            throw new DocumentPermissionDeniedException("No permission to view document");
        }
        
        // æ£€æŸ¥æ˜¯å¦å·²ç»ç‚¹èµ
        if (hasUserLikedDocument(documentId, user.getId())) {
            throw new DocumentAlreadyLikedException("User already liked this document");
        }
        
        // å¢åŠ ç‚¹èµæ•°
        document.incrementLikeCount();
        documentRepository.save(document);
        
        // è®°å½•ç‚¹èµ
        recordDocumentLike(documentId, user.getId());
        
        // å‘å¸ƒäº‹ä»¶
        DomainEventPublisher.publish(new DocumentLikedEvent(documentId, user.getId()));
    }
    
    /**
     * å–æ¶ˆç‚¹èµ
     */
    public void unlikeDocument(Long documentId, User user) {
        Document document = documentRepository.findById(documentId)
            .orElseThrow(() -> new DocumentNotFoundException("Document not found: " + documentId));
        
        // æ£€æŸ¥æ˜¯å¦å·²ç»ç‚¹èµ
        if (!hasUserLikedDocument(documentId, user.getId())) {
            throw new DocumentNotLikedException("User has not liked this document");
        }
        
        // å‡å°‘ç‚¹èµæ•°
        document.decrementLikeCount();
        documentRepository.save(document);
        
        // åˆ é™¤ç‚¹èµè®°å½•
        removeDocumentLike(documentId, user.getId());
        
        // å‘å¸ƒäº‹ä»¶
        DomainEventPublisher.publish(new DocumentUnlikedEvent(documentId, user.getId()));
    }
    
    /**
     * æœç´¢æ–‡æ¡£
     */
    public Page<Document> searchDocuments(DocumentSearchQuery query) {
        return searchService.searchDocuments(query);
    }
    
    // ç§æœ‰æ–¹æ³•
    private void handleFileUpload(Document document, MultipartFile file) {
        try {
            // ä¸Šä¼ æ–‡ä»¶
            String filePath = fileStorageService.storeFile(file);
            document.setFilePath(filePath);
            document.setFileSize(file.getSize());
            document.setFileType(file.getContentType());
            
            // ç”Ÿæˆç¼©ç•¥å›¾ï¼ˆå¦‚æœæ˜¯å›¾ç‰‡ï¼‰
            if (isImageFile(file.getContentType())) {
                String thumbnailPath = fileStorageService.generateThumbnail(filePath);
                document.setThumbnailPath(thumbnailPath);
            }
            
        } catch (Exception e) {
            throw new FileUploadException("Failed to upload file", e);
        }
    }
    
    private void handleTags(Document document, Set<Long> tagIds) {
        if (tagIds != null && !tagIds.isEmpty()) {
            // æ¸…é™¤ç°æœ‰æ ‡ç­¾
            document.getTags().clear();
            
            // æ·»åŠ æ–°æ ‡ç­¾
            for (Long tagId : tagIds) {
                Tag tag = tagRepository.findById(tagId)
                    .orElseThrow(() -> new TagNotFoundException("Tag not found: " + tagId));
                document.addTag(tag);
            }
        }
    }
    
    private boolean isImageFile(String contentType) {
        return contentType != null && contentType.startsWith("image/");
    }
    
    private boolean hasUserLikedDocument(Long documentId, Long userId) {
        // å®ç°æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²ç‚¹èµçš„é€»è¾‘
        return documentLikeRepository.existsByDocumentIdAndUserId(documentId, userId);
    }
    
    private void recordDocumentLike(Long documentId, Long userId) {
        DocumentLike like = new DocumentLike();
        like.setDocumentId(documentId);
        like.setUserId(userId);
        like.setCreatedAt(LocalDateTime.now());
        documentLikeRepository.save(like);
    }
    
    private void removeDocumentLike(Long documentId, Long userId) {
        documentLikeRepository.deleteByDocumentIdAndUserId(documentId, userId);
    }
}
```

### 3. æœç´¢æœåŠ¡è®¾è®¡

#### ElasticsearchDocumentService
```java
@Service
@Slf4j
public class ElasticsearchDocumentService implements SearchService {
    
    private final ElasticsearchOperations elasticsearchOperations;
    private final DocumentRepository documentRepository;
    
    public ElasticsearchDocumentService(ElasticsearchOperations elasticsearchOperations,
                                       DocumentRepository documentRepository) {
        this.elasticsearchOperations = elasticsearchOperations;
        this.documentRepository = documentRepository;
    }
    
    @Override
    public void indexDocument(Document document) {
        try {
            DocumentDocument documentDocument = DocumentMapper.toDocumentDocument(document);
            elasticsearchOperations.save(documentDocument);
            log.info("Successfully indexed document: {}", document.getId());
        } catch (Exception e) {
            log.error("Failed to index document: {}", document.getId(), e);
            throw new SearchIndexException("Failed to index document", e);
        }
    }
    
    @Override
    public void updateDocument(Document document) {
        indexDocument(document);
    }
    
    @Override
    public void deleteDocument(Long documentId) {
        try {
            elasticsearchOperations.delete(DocumentDocument.class, documentId.toString());
            log.info("Successfully deleted document from index: {}", documentId);
        } catch (Exception e) {
            log.error("Failed to delete document from index: {}", documentId, e);
            throw new SearchIndexException("Failed to delete document from index", e);
        }
    }
    
    @Override
    public Page<Document> searchDocuments(DocumentSearchQuery query) {
        try {
            NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder();
            
            // æ„å»ºæœç´¢æ¡ä»¶
            BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
            
            // å…³é”®è¯æœç´¢
            if (StringUtils.hasText(query.getKeyword())) {
                boolQuery.must(QueryBuilders.multiMatchQuery(query.getKeyword())
                    .field("title", 2.0f)
                    .field("content", 1.0f)
                    .field("summary", 1.5f)
                    .type(MultiMatchQueryBuilder.Type.BEST_FIELDS));
            }
            
            // åˆ†ç±»è¿‡æ»¤
            if (query.getCategoryId() != null) {
                boolQuery.filter(QueryBuilders.termQuery("categoryId", query.getCategoryId()));
            }
            
            // ä½œè€…è¿‡æ»¤
            if (query.getAuthorId() != null) {
                boolQuery.filter(QueryBuilders.termQuery("authorId", query.getAuthorId()));
            }
            
            // çŠ¶æ€è¿‡æ»¤
            if (query.getStatus() != null) {
                boolQuery.filter(QueryBuilders.termQuery("status", query.getStatus().name()));
            }
            
            // æ ‡ç­¾è¿‡æ»¤
            if (query.getTagIds() != null && !query.getTagIds().isEmpty()) {
                boolQuery.filter(QueryBuilders.termsQuery("tagIds", query.getTagIds()));
            }
            
            // æ—¥æœŸèŒƒå›´è¿‡æ»¤
            if (query.getStartDate() != null || query.getEndDate() != null) {
                RangeQueryBuilder dateRange = QueryBuilders.rangeQuery("createdAt");
                if (query.getStartDate() != null) {
                    dateRange.gte(query.getStartDate().toString());
                }
                if (query.getEndDate() != null) {
                    dateRange.lte(query.getEndDate().toString());
                }
                boolQuery.filter(dateRange);
            }
            
            // è®¾ç½®æŸ¥è¯¢
            queryBuilder.withQuery(boolQuery);
            
            // æ’åº
            if (StringUtils.hasText(query.getSortField())) {
                SortOrder sortOrder = query.getSortDirection() == SortDirection.DESC ? 
                    SortOrder.DESC : SortOrder.ASC;
                queryBuilder.withSort(SortBuilders.fieldSort(query.getSortField()).order(sortOrder));
            } else {
                // é»˜è®¤æŒ‰åˆ›å»ºæ—¶é—´æ’åº
                queryBuilder.withSort(SortBuilders.fieldSort("createdAt").order(SortOrder.DESC));
            }
            
            // åˆ†é¡µ
            queryBuilder.withPageable(PageRequest.of(query.getPage(), query.getSize()));
            
            // é«˜äº®
            if (StringUtils.hasText(query.getKeyword())) {
                queryBuilder.withHighlightFields(
                    new HighlightBuilder.Field("title"),
                    new HighlightBuilder.Field("content"),
                    new HighlightBuilder.Field("summary")
                );
            }
            
            // æ‰§è¡Œæœç´¢
            SearchHits<DocumentDocument> searchHits = elasticsearchOperations.search(queryBuilder.build(), DocumentDocument.class);
            
            // è½¬æ¢ç»“æœ
            List<Document> documents = searchHits.stream()
                .map(this::convertToDocument)
                .collect(Collectors.toList());
            
            return new PageImpl<>(documents, 
                PageRequest.of(query.getPage(), query.getSize()), 
                searchHits.getTotalHits());
            
        } catch (Exception e) {
            log.error("Failed to search documents", e);
            throw new SearchException("Failed to search documents", e);
        }
    }
    
    @Override
    public List<String> suggest(String keyword) {
        try {
            CompletionSuggestionBuilder suggestionBuilder = SuggestBuilders
                .completionSuggestion("titleSuggest")
                .text(keyword)
                .size(10);
            
            SuggestBuilder suggestBuilder = new SuggestBuilder()
                .addSuggestion("titleSuggest", suggestionBuilder);
            
            SearchRequest searchRequest = new SearchRequest("documents")
                .source(new SearchSourceBuilder().suggest(suggestBuilder));
            
            SearchResponse response = elasticsearchOperations
                .elasticsearchClient()
                .search(searchRequest, RequestOptions.DEFAULT);
            
            return response.getSuggest()
                .getSuggestion("titleSuggest")
                .getEntries()
                .stream()
                .flatMap(entry -> entry.getOptions().stream())
                .map(option -> option.getText().string())
                .collect(Collectors.toList());
            
        } catch (Exception e) {
            log.error("Failed to get suggestions", e);
            return Collections.emptyList();
        }
    }
    
    private Document convertToDocument(SearchHit<DocumentDocument> searchHit) {
        DocumentDocument documentDocument = searchHit.getContent();
        Document document = DocumentMapper.toDocument(documentDocument);
        
        // è®¾ç½®é«˜äº®ä¿¡æ¯
        if (searchHit.getHighlightFields() != null) {
            Map<String, List<String>> highlightFields = searchHit.getHighlightFields();
            if (highlightFields.containsKey("title")) {
                document.setHighlightedTitle(String.join("...", highlightFields.get("title")));
            }
            if (highlightFields.containsKey("content")) {
                document.setHighlightedContent(String.join("...", highlightFields.get("content")));
            }
        }
        
        return document;
    }
}
```

---

*æœ¬æ–‡æ¡£æä¾›äº†ç³»ç»Ÿçš„è¯¦ç»†è®¾è®¡ï¼ŒåŒ…æ‹¬å®ä½“è®¾è®¡ã€æœåŠ¡å±‚è®¾è®¡ã€æ§åˆ¶å™¨è®¾è®¡ã€DTOè®¾è®¡ç­‰ï¼Œä¸ºå¼€å‘äººå‘˜æä¾›äº†å…·ä½“çš„å®ç°æŒ‡å¯¼ã€‚*