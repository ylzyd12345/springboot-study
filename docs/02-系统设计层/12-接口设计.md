# Junmo Platform æ¥å£è®¾è®¡

## ğŸ“‹ æ–‡æ¡£ä¿¡æ¯

| é¡¹ç›® | å†…å®¹ |
|------|------|
| **æ–‡æ¡£åç§°** | Junmo Platform æ¥å£è®¾è®¡ |
| **ç‰ˆæœ¬å·** | v1.0.0 |
| **åˆ›å»ºæ—¥æœŸ** | 2025-12-24 |
| **ä½œè€…** | APIæ¶æ„å¸ˆ |
| **å®¡æ ¸äºº** | åç«¯æ¶æ„å¸ˆ |
| **æ‰¹å‡†äºº** | æŠ€æœ¯æ€»ç›‘ |

## ğŸ¯ æ¥å£è®¾è®¡æ¦‚è¿°

Junmo Platformé‡‡ç”¨RESTful APIè®¾è®¡é£æ ¼ï¼Œç»“åˆGraphQLæŸ¥è¯¢è¯­è¨€å’ŒWebSocketå®æ—¶é€šä¿¡ï¼Œæ„å»ºå®Œæ•´çš„APIæœåŠ¡ä½“ç³»ã€‚æ‰€æœ‰æ¥å£éµå¾ªç»Ÿä¸€çš„è§„èŒƒï¼ŒåŒ…æ‹¬ç‰ˆæœ¬æ§åˆ¶ã€è®¤è¯æˆæƒã€é”™è¯¯å¤„ç†ã€é™æµç†”æ–­ç­‰æœºåˆ¶ï¼Œç¡®ä¿æ¥å£çš„å¯é æ€§ã€å®‰å…¨æ€§å’Œå¯æ‰©å±•æ€§ã€‚

## ğŸ”§ æ¥å£æ¶æ„è®¾è®¡

### 1. APIæ¶æ„åˆ†å±‚

```mermaid
graph TB
    subgraph "å®¢æˆ·ç«¯å±‚"
        A1[Webå‰ç«¯] --> A2[ç§»åŠ¨ç«¯]
        A3[ç¬¬ä¸‰æ–¹åº”ç”¨] --> A4[å¼€æ”¾å¹³å°]
    end
    
    subgraph "ç½‘å…³å±‚"
        B1[APIç½‘å…³] --> B2[è´Ÿè½½å‡è¡¡]
        B3[é™æµç†”æ–­] --> B4[è®¤è¯æˆæƒ]
    end
    
    subgraph "æ¥å£å±‚"
        C1[REST API] --> C2[GraphQL API]
        C3[WebSocket API] --> C4[æ–‡ä»¶ä¸Šä¼ API]
    end
    
    subgraph "ä¸šåŠ¡å±‚"
        D1[ç”¨æˆ·æœåŠ¡] --> D2[æ–‡æ¡£æœåŠ¡]
        D3[å·¥ä½œæµæœåŠ¡] --> D4[é€šçŸ¥æœåŠ¡]
    end
    
    A1 --> B1
    A2 --> B1
    A3 --> B1
    A4 --> B1
    B1 --> C1
    B2 --> C2
    B3 --> C3
    B4 --> C4
    C1 --> D1
    C2 --> D2
    C3 --> D3
    C4 --> D4
```

### 2. APIç‰ˆæœ¬æ§åˆ¶ç­–ç•¥

**ç‰ˆæœ¬æ§åˆ¶å®ç°**:

```java
// APIç‰ˆæœ¬é…ç½®
@Configuration
public class ApiVersionConfig {
    
    @Bean
    public WebMvcConfigurer apiVersionConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
                configurer.favorParameter(true)
                    .parameterName("version")
                    .ignoreAcceptHeader(false)
                    .defaultContentType(MediaType.APPLICATION_JSON)
                    .mediaType("v1", MediaType.APPLICATION_JSON)
                    .mediaType("v2", MediaType.APPLICATION_JSON);
            }
        };
    }
}

// APIç‰ˆæœ¬æ³¨è§£
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface ApiVersion {
    int value();
}

// APIç‰ˆæœ¬æ‹¦æˆªå™¨
@Component
public class ApiVersionInterceptor implements HandlerInterceptor {
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        if (handler instanceof HandlerMethod) {
            HandlerMethod handlerMethod = (HandlerMethod) handler;
            ApiVersion apiVersion = handlerMethod.getMethodAnnotation(ApiVersion.class);
            
            if (apiVersion != null) {
                String requestVersion = request.getParameter("version");
                if (requestVersion == null) {
                    requestVersion = "1"; // é»˜è®¤ç‰ˆæœ¬
                }
                
                if (!String.valueOf(apiVersion.value()).equals(requestVersion)) {
                    response.setStatus(HttpStatus.NOT_FOUND.value());
                    response.getWriter().write("{\"error\":\"API version not supported\"}");
                    return false;
                }
            }
        }
        return true;
    }
}
```

### 3. ç»Ÿä¸€å“åº”æ ¼å¼

**å“åº”å®ä½“è®¾è®¡**:

```java
// ç»Ÿä¸€å“åº”ç»“æœ
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {
    
    private int code;
    private String message;
    private T data;
    private Long timestamp;
    private String requestId;
    
    public static <T> ApiResponse<T> success(T data) {
        return ApiResponse.<T>builder()
            .code(200)
            .message("Success")
            .data(data)
            .timestamp(System.currentTimeMillis())
            .build();
    }
    
    public static <T> ApiResponse<T> success(T data, String message) {
        return ApiResponse.<T>builder()
            .code(200)
            .message(message)
            .data(data)
            .timestamp(System.currentTimeMillis())
            .build();
    }
    
    public static <T> ApiResponse<T> error(int code, String message) {
        return ApiResponse.<T>builder()
            .code(code)
            .message(message)
            .timestamp(System.currentTimeMillis())
            .build();
    }
    
    public static <T> ApiResponse<T> error(ErrorCode errorCode) {
        return ApiResponse.<T>builder()
            .code(errorCode.getCode())
            .message(errorCode.getMessage())
            .timestamp(System.currentTimeMillis())
            .build();
    }
}

// åˆ†é¡µå“åº”ç»“æœ
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PageResponse<T> {
    
    private List<T> content;
    private long totalElements;
    private int totalPages;
    private int currentPage;
    private int size;
    private boolean first;
    private boolean last;
    
    public static <T> PageResponse<T> of(Page<T> page) {
        return PageResponse.<T>builder()
            .content(page.getContent())
            .totalElements(page.getTotalElements())
            .totalPages(page.getTotalPages())
            .currentPage(page.getNumber())
            .size(page.getSize())
            .first(page.isFirst())
            .last(page.isLast())
            .build();
    }
}

// é”™è¯¯ç æšä¸¾
public enum ErrorCode {
    SUCCESS(200, "Success"),
    BAD_REQUEST(400, "Bad Request"),
    UNAUTHORIZED(401, "Unauthorized"),
    FORBIDDEN(403, "Forbidden"),
    NOT_FOUND(404, "Not Found"),
    INTERNAL_ERROR(500, "Internal Server Error"),
    
    // ä¸šåŠ¡é”™è¯¯ç 
    USER_NOT_FOUND(1001, "User not found"),
    USER_ALREADY_EXISTS(1002, "User already exists"),
    INVALID_PASSWORD(1003, "Invalid password"),
    TOKEN_EXPIRED(1004, "Token expired"),
    
    DOCUMENT_NOT_FOUND(2001, "Document not found"),
    DOCUMENT_ACCESS_DENIED(2002, "Document access denied"),
    DOCUMENT_VERSION_CONFLICT(2003, "Document version conflict");
    
    private final int code;
    private final String message;
    
    ErrorCode(int code, String message) {
        this.code = code;
        this.message = message;
    }
    
    public int getCode() {
        return code;
    }
    
    public String getMessage() {
        return message;
    }
}
```

## ğŸ‘¤ ç”¨æˆ·ç®¡ç†API

### 1. ç”¨æˆ·è®¤è¯æ¥å£

#### 1.1 ç”¨æˆ·ç™»å½•

```yaml
# ç”¨æˆ·ç™»å½•æ¥å£
POST /api/v1/auth/login
Content-Type: application/json

# è¯·æ±‚ä½“
{
  "username": "admin",
  "password": "password123",
  "captcha": "abc123",
  "rememberMe": false
}

# å“åº”ä½“
{
  "code": 200,
  "message": "Login successful",
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "tokenType": "Bearer",
    "expiresIn": 3600,
    "user": {
      "id": 1,
      "username": "admin",
      "email": "admin@example.com",
      "firstName": "Admin",
      "lastName": "User",
      "avatarUrl": "https://example.com/avatar.jpg",
      "roles": ["ADMIN"],
      "permissions": ["user:*", "document:*", "workflow:*"]
    }
  },
  "timestamp": 1703424000000
}
```

**æ§åˆ¶å™¨å®ç°**:

```java
@RestController
@RequestMapping("/api/v1/auth")
@Validated
@Slf4j
public class AuthController {
    
    @Autowired
    private AuthService authService;
    
    @Autowired
    private CaptchaService captchaService;
    
    /**
     * ç”¨æˆ·ç™»å½•
     */
    @PostMapping("/login")
    public ApiResponse<LoginResponse> login(@Valid @RequestBody LoginRequest request) {
        log.info("User login attempt: {}", request.getUsername());
        
        // éªŒè¯éªŒè¯ç 
        if (!captchaService.validate(request.getCaptcha(), request.getCaptchaId())) {
            throw new InvalidCaptchaException("Invalid captcha");
        }
        
        LoginResponse response = authService.login(request);
        
        return ApiResponse.success(response, "Login successful");
    }
    
    /**
     * åˆ·æ–°Token
     */
    @PostMapping("/refresh")
    public ApiResponse<TokenResponse> refresh(@Valid @RequestBody RefreshTokenRequest request) {
        TokenResponse response = authService.refreshToken(request.getRefreshToken());
        return ApiResponse.success(response);
    }
    
    /**
     * ç”¨æˆ·ç™»å‡º
     */
    @PostMapping("/logout")
    @PreAuthorize("isAuthenticated()")
    public ApiResponse<Void> logout(@RequestHeader("Authorization") String authorization) {
        String token = authorization.replace("Bearer ", "");
        authService.logout(token);
        return ApiResponse.success();
    }
    
    /**
     * è·å–éªŒè¯ç 
     */
    @GetMapping("/captcha")
    public ApiResponse<CaptchaResponse> getCaptcha() {
        CaptchaResponse captcha = captchaService.generateCaptcha();
        return ApiResponse.success(captcha);
    }
}
```

#### 1.2 ç”¨æˆ·æ³¨å†Œ

```yaml
# ç”¨æˆ·æ³¨å†Œæ¥å£
POST /api/v1/auth/register
Content-Type: application/json

# è¯·æ±‚ä½“
{
  "username": "newuser",
  "email": "newuser@example.com",
  "password": "Password123!",
  "firstName": "New",
  "lastName": "User",
  "phoneNumber": "+1234567890",
  "captcha": "xyz789",
  "captchaId": "captcha_123",
  "agreeTerms": true
}

# å“åº”ä½“
{
  "code": 200,
  "message": "Registration successful",
  "data": {
    "user": {
      "id": 2,
      "username": "newuser",
      "email": "newuser@example.com",
      "firstName": "New",
      "lastName": "User",
      "phoneNumber": "+1234567890",
      "status": "ACTIVE",
      "emailVerified": false,
      "phoneVerified": false,
      "createdAt": "2023-12-24T10:00:00Z"
    },
    "verificationToken": "email_verification_token_123"
  },
  "timestamp": 1703424000000
}
```

**æœåŠ¡å±‚å®ç°**:

```java
@Service
@Transactional
public class AuthServiceImpl implements AuthService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    @Autowired
    private JwtTokenProvider tokenProvider;
    
    @Autowired
    private EmailService emailService;
    
    @Override
    public LoginResponse login(LoginRequest request) {
        // 1. æŸ¥æ‰¾ç”¨æˆ·
        User user = userRepository.findByUsername(request.getUsername())
            .orElseThrow(() -> new AuthenticationException("Invalid credentials"));
        
        // 2. éªŒè¯å¯†ç 
        if (!passwordEncoder.matches(request.getPassword(), user.getPassword())) {
            throw new AuthenticationException("Invalid credentials");
        }
        
        // 3. æ£€æŸ¥ç”¨æˆ·çŠ¶æ€
        if (!user.isActive()) {
            throw new UserLockedException("User account is locked");
        }
        
        // 4. æ›´æ–°ç™»å½•ä¿¡æ¯
        user.updateLoginInfo(request.getIpAddress());
        userRepository.save(user);
        
        // 5. ç”ŸæˆToken
        String accessToken = tokenProvider.generateAccessToken(user);
        String refreshToken = tokenProvider.generateRefreshToken(user);
        
        // 6. æ„å»ºå“åº”
        return LoginResponse.builder()
            .accessToken(accessToken)
            .refreshToken(refreshToken)
            .tokenType("Bearer")
            .expiresIn(tokenProvider.getAccessTokenExpiration())
            .user(UserMapper.toDTO(user))
            .build();
    }
    
    @Override
    public UserDTO register(RegisterRequest request) {
        // 1. éªŒè¯ç”¨æˆ·åå”¯ä¸€æ€§
        if (userRepository.existsByUsername(request.getUsername())) {
            throw new UserAlreadyExistsException("Username already exists");
        }
        
        // 2. éªŒè¯é‚®ç®±å”¯ä¸€æ€§
        if (userRepository.existsByEmail(request.getEmail())) {
            throw new UserAlreadyExistsException("Email already exists");
        }
        
        // 3. åˆ›å»ºç”¨æˆ·
        User user = User.create(
            request.getUsername(),
            request.getEmail(),
            passwordEncoder.encode(request.getPassword())
        );
        user.setFirstName(request.getFirstName());
        user.setLastName(request.getLastName());
        user.setPhoneNumber(request.getPhoneNumber());
        
        // 4. åˆ†é…é»˜è®¤è§’è‰²
        assignDefaultRole(user);
        
        // 5. ä¿å­˜ç”¨æˆ·
        user = userRepository.save(user);
        
        // 6. å‘é€éªŒè¯é‚®ä»¶
        String verificationToken = generateVerificationToken(user);
        emailService.sendVerificationEmail(user.getEmail(), verificationToken);
        
        return UserMapper.toDTO(user);
    }
}
```

### 2. ç”¨æˆ·ç®¡ç†æ¥å£

#### 2.1 è·å–ç”¨æˆ·åˆ—è¡¨

```yaml
# è·å–ç”¨æˆ·åˆ—è¡¨æ¥å£
GET /api/v1/users?page=0&size=20&keyword=admin&status=ACTIVE&roleId=1
Authorization: Bearer {accessToken}

# å“åº”ä½“
{
  "code": 200,
  "message": "Success",
  "data": {
    "content": [
      {
        "id": 1,
        "username": "admin",
        "email": "admin@example.com",
        "firstName": "Admin",
        "lastName": "User",
        "phoneNumber": "+1234567890",
        "avatarUrl": "https://example.com/avatar.jpg",
        "status": "ACTIVE",
        "lastLoginTime": "2023-12-24T09:30:00Z",
        "lastLoginIp": "192.168.1.100",
        "loginCount": 42,
        "emailVerified": true,
        "phoneVerified": true,
        "roles": [
          {
            "id": 1,
            "name": "ADMIN",
            "description": "Administrator"
          }
        ],
        "createdAt": "2023-01-01T00:00:00Z",
        "updatedAt": "2023-12-24T09:30:00Z"
      }
    ],
    "totalElements": 1,
    "totalPages": 1,
    "currentPage": 0,
    "size": 20,
    "first": true,
    "last": true
  },
  "timestamp": 1703424000000
}
```

**æ§åˆ¶å™¨å®ç°**:

```java
@RestController
@RequestMapping("/api/v1/users")
@PreAuthorize("hasRole('ADMIN')")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    /**
     * è·å–ç”¨æˆ·åˆ—è¡¨
     */
    @GetMapping
    public ApiResponse<PageResponse<UserDTO>> getUsers(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(required = false) String keyword,
            @RequestParam(required = false) UserStatus status,
            @RequestParam(required = false) Long roleId) {
        
        UserQuery query = UserQuery.builder()
            .page(page)
            .size(size)
            .keyword(keyword)
            .status(status)
            .roleId(roleId)
            .build();
        
        Page<UserDTO> users = userService.findUsers(query);
        PageResponse<UserDTO> response = PageResponse.of(users);
        
        return ApiResponse.success(response);
    }
    
    /**
     * è·å–ç”¨æˆ·è¯¦æƒ…
     */
    @GetMapping("/{id}")
    public ApiResponse<UserDTO> getUser(@PathVariable Long id) {
        User user = userService.findUserById(id);
        UserDTO userDTO = UserMapper.toDTO(user);
        return ApiResponse.success(userDTO);
    }
    
    /**
     * åˆ›å»ºç”¨æˆ·
     */
    @PostMapping
    public ApiResponse<UserDTO> createUser(@Valid @RequestBody CreateUserRequest request) {
        User user = userService.createUser(request);
        UserDTO userDTO = UserMapper.toDTO(user);
        return ApiResponse.success(userDTO, "User created successfully");
    }
    
    /**
     * æ›´æ–°ç”¨æˆ·
     */
    @PutMapping("/{id}")
    public ApiResponse<UserDTO> updateUser(
            @PathVariable Long id,
            @Valid @RequestBody UpdateUserRequest request) {
        
        User user = userService.updateUser(id, request);
        UserDTO userDTO = UserMapper.toDTO(user);
        return ApiResponse.success(userDTO, "User updated successfully");
    }
    
    /**
     * åˆ é™¤ç”¨æˆ·
     */
    @DeleteMapping("/{id}")
    public ApiResponse<Void> deleteUser(@PathVariable Long id) {
        userService.deleteUser(id);
        return ApiResponse.success(null, "User deleted successfully");
    }
    
    /**
     * é‡ç½®å¯†ç 
     */
    @PostMapping("/{id}/reset-password")
    public ApiResponse<Void> resetPassword(@PathVariable Long id) {
        userService.resetPassword(id);
        return ApiResponse.success(null, "Password reset email sent");
    }
    
    /**
     * åˆ†é…è§’è‰²
     */
    @PutMapping("/{id}/roles")
    public ApiResponse<Void> assignRoles(
            @PathVariable Long id,
            @Valid @RequestBody AssignRolesRequest request) {
        
        userService.assignRoles(id, request.getRoleIds());
        return ApiResponse.success(null, "Roles assigned successfully");
    }
}
```

## ğŸ“„ æ–‡æ¡£ç®¡ç†API

### 1. æ–‡æ¡£CRUDæ¥å£

#### 1.1 åˆ›å»ºæ–‡æ¡£

```yaml
# åˆ›å»ºæ–‡æ¡£æ¥å£
POST /api/v1/documents
Authorization: Bearer {accessToken}
Content-Type: application/json

# è¯·æ±‚ä½“
{
  "title": "Spring Bootæœ€ä½³å®è·µ",
  "content": "Spring Bootæ˜¯ä¸€ä¸ªå¿«é€Ÿå¼€å‘æ¡†æ¶...",
  "summary": "æœ¬æ–‡ä»‹ç»Spring Bootçš„æœ€ä½³å®è·µ",
  "categoryId": 1,
  "tags": ["Spring Boot", "Java", "æœ€ä½³å®è·µ"],
  "accessLevel": "PUBLIC",
  "status": "DRAFT",
  "attachments": [
    {
      "name": "spring-boot-guide.pdf",
      "type": "application/pdf",
      "size": 1024000,
      "url": "https://example.com/files/spring-boot-guide.pdf"
    }
  ]
}

# å“åº”ä½“
{
  "code": 200,
  "message": "Document created successfully",
  "data": {
    "id": 1,
    "title": "Spring Bootæœ€ä½³å®è·µ",
    "content": "Spring Bootæ˜¯ä¸€ä¸ªå¿«é€Ÿå¼€å‘æ¡†æ¶...",
    "summary": "æœ¬æ–‡ä»‹ç»Spring Bootçš„æœ€ä½³å®è·µ",
    "category": {
      "id": 1,
      "name": "æŠ€æœ¯æ–‡æ¡£",
      "path": "/æŠ€æœ¯æ–‡æ¡£"
    },
    "author": {
      "id": 1,
      "username": "admin",
      "displayName": "Admin User"
    },
    "tags": ["Spring Boot", "Java", "æœ€ä½³å®è·µ"],
    "status": "DRAFT",
    "version": 1,
    "accessLevel": "PUBLIC",
    "viewCount": 0,
    "likeCount": 0,
    "attachments": [
      {
        "id": 1,
        "name": "spring-boot-guide.pdf",
        "type": "application/pdf",
        "size": 1024000,
        "url": "https://example.com/files/spring-boot-guide.pdf"
      }
    ],
    "createdAt": "2023-12-24T10:00:00Z",
    "updatedAt": "2023-12-24T10:00:00Z"
  },
  "timestamp": 1703424000000
}
```

**æœåŠ¡å±‚å®ç°**:

```java
@Service
@Transactional
public class DocumentServiceImpl implements DocumentService {
    
    @Autowired
    private DocumentRepository documentRepository;
    
    @Autowired
    private CategoryRepository categoryRepository;
    
    @Autowired
    private TagRepository tagRepository;
    
    @Autowired
    private SearchService searchService;
    
    @Override
    public Document createDocument(CreateDocumentRequest request, Long authorId) {
        // 1. éªŒè¯åˆ†ç±»
        Category category = categoryRepository.findById(request.getCategoryId())
            .orElseThrow(() -> new CategoryNotFoundException("Category not found"));
        
        // 2. åˆ›å»ºæ–‡æ¡£
        Document document = Document.create(
            request.getTitle(),
            request.getContent(),
            authorId,
            category.getId()
        );
        
        document.setSummary(request.getSummary());
        document.setAccessLevel(request.getAccessLevel());
        document.setStatus(request.getStatus());
        
        // 3. å¤„ç†æ ‡ç­¾
        if (request.getTags() != null && !request.getTags().isEmpty()) {
            Set<Tag> tags = findOrCreateTags(request.getTags());
            document.setTags(tags);
        }
        
        // 4. å¤„ç†é™„ä»¶
        if (request.getAttachments() != null && !request.getAttachments().isEmpty()) {
            Set<Attachment> attachments = request.getAttachments().stream()
                .map(attachmentMapper::toEntity)
                .collect(Collectors.toSet());
            document.setAttachments(attachments);
        }
        
        // 5. ä¿å­˜æ–‡æ¡£
        document = documentRepository.save(document);
        
        // 6. ç´¢å¼•åˆ°æœç´¢å¼•æ“
        searchService.indexDocument(document);
        
        // 7. å‘å¸ƒäº‹ä»¶
        eventPublisher.publishEvent(new DocumentCreatedEvent(document.getId()));
        
        return document;
    }
    
    @Override
    public Document updateDocument(Long documentId, UpdateDocumentRequest request, Long userId) {
        // 1. è·å–æ–‡æ¡£
        Document document = documentRepository.findById(documentId)
            .orElseThrow(() -> new DocumentNotFoundException("Document not found"));
        
        // 2. æ£€æŸ¥æƒé™
        if (!document.canEdit(userId)) {
            throw new DocumentAccessDeniedException("Access denied");
        }
        
        // 3. æ›´æ–°æ–‡æ¡£
        document.update(request.getTitle(), request.getContent());
        document.setSummary(request.getSummary());
        
        if (request.getCategoryId() != null) {
            Category category = categoryRepository.findById(request.getCategoryId())
                .orElseThrow(() -> new CategoryNotFoundException("Category not found"));
            document.setCategory(category);
        }
        
        // 4. æ›´æ–°æ ‡ç­¾
        if (request.getTags() != null) {
            Set<Tag> tags = findOrCreateTags(request.getTags());
            document.setTags(tags);
        }
        
        // 5. ä¿å­˜æ›´æ–°
        document = documentRepository.save(document);
        
        // 6. æ›´æ–°æœç´¢ç´¢å¼•
        searchService.indexDocument(document);
        
        // 7. å‘å¸ƒäº‹ä»¶
        eventPublisher.publishEvent(new DocumentUpdatedEvent(document.getId()));
        
        return document;
    }
    
    private Set<Tag> findOrCreateTags(Set<String> tagNames) {
        return tagNames.stream()
            .map(tagName -> {
                return tagRepository.findByName(tagName)
                    .orElseGet(() -> {
                        Tag tag = Tag.create(tagName);
                        return tagRepository.save(tag);
                    });
            })
            .collect(Collectors.toSet());
    }
}
```

#### 1.2 æœç´¢æ–‡æ¡£

```yaml
# æœç´¢æ–‡æ¡£æ¥å£
GET /api/v1/documents/search?keyword=Spring%20Boot&categoryIds=1,2&tags=Java&status=PUBLISHED&page=0&size=10&sortBy=relevance&includeAggregations=true
Authorization: Bearer {accessToken}

# å“åº”ä½“
{
  "code": 200,
  "message": "Search completed",
  "data": {
    "content": [
      {
        "id": 1,
        "title": "Spring Bootæœ€ä½³å®è·µ",
        "summary": "æœ¬æ–‡ä»‹ç»Spring Bootçš„æœ€ä½³å®è·µ",
        "highlightedTitle": "<em>Spring Boot</em>æœ€ä½³å®è·µ",
        "highlightedContent": "<em>Spring Boot</em>æ˜¯ä¸€ä¸ªå¿«é€Ÿå¼€å‘æ¡†æ¶...",
        "author": {
          "id": 1,
          "username": "admin",
          "displayName": "Admin User"
        },
        "category": {
          "id": 1,
          "name": "æŠ€æœ¯æ–‡æ¡£"
        },
        "tags": ["Spring Boot", "Java", "æœ€ä½³å®è·µ"],
        "status": "PUBLISHED",
        "viewCount": 150,
        "likeCount": 25,
        "publishedAt": "2023-12-24T10:00:00Z",
        "score": 0.95
      }
    ],
    "totalElements": 1,
    "totalPages": 1,
    "currentPage": 0,
    "size": 10,
    "aggregations": {
      "categories": [
        {
          "name": "æŠ€æœ¯æ–‡æ¡£",
          "count": 1
        }
      ],
      "tags": [
        {
          "name": "Spring Boot",
          "count": 1
        },
        {
          "name": "Java",
          "count": 1
        }
      ],
      "authors": [
        {
          "name": "admin",
          "count": 1
        }
      ],
      "dateHistogram": [
        {
          "date": "2023-12",
          "count": 1
        }
      ]
    }
  },
  "timestamp": 1703424000000
}
```

## ğŸ”„ å·¥ä½œæµAPI

### 1. æµç¨‹ç®¡ç†æ¥å£

#### 1.1 å¯åŠ¨æµç¨‹

```yaml
# å¯åŠ¨æµç¨‹æ¥å£
POST /api/v1/workflow/processes/{processKey}/start
Authorization: Bearer {accessToken}
Content-Type: application/json

# è¯·æ±‚ä½“
{
  "businessKey": "LEAVE_20231224_001",
  "variables": {
    "applicant": "å¼ ä¸‰",
    "leaveDays": 3,
    "reason": "å®¶ä¸­æœ‰äº‹",
    "startDate": "2023-12-25",
    "endDate": "2023-12-27"
  }
}

# å“åº”ä½“
{
  "code": 200,
  "message": "Process started successfully",
  "data": {
    "processInstanceId": "proc_123456789",
    "processDefinitionId": 1,
    "processDefinitionKey": "leave_approval",
    "businessKey": "LEAVE_20231224_001",
    "status": "RUNNING",
    "startedBy": 1,
    "startTime": "2023-12-24T10:00:00Z",
    "variables": {
      "applicant": "å¼ ä¸‰",
      "leaveDays": 3,
      "reason": "å®¶ä¸­æœ‰äº‹",
      "startDate": "2023-12-25",
      "endDate": "2023-12-27"
    },
    "tasks": [
      {
        "taskId": "task_123456789",
        "name": "éƒ¨é—¨ç»ç†å®¡æ‰¹",
        "assignee": 2,
        "status": "ACTIVE",
        "createTime": "2023-12-24T10:00:00Z",
        "dueTime": "2023-12-25T10:00:00Z"
      }
    ]
  },
  "timestamp": 1703424000000
}
```

**æœåŠ¡å±‚å®ç°**:

```java
@Service
@Transactional
public class WorkflowServiceImpl implements WorkflowService {
    
    @Autowired
    private ProcessDefinitionRepository processDefinitionRepository;
    
    @Autowired
    private ProcessInstanceRepository processInstanceRepository;
    
    @Autowired
    private TaskInstanceRepository taskInstanceRepository;
    
    @Autowired
    private BpmnProcessEngine processEngine;
    
    @Override
    public ProcessInstance startProcess(String processKey, StartProcessRequest request, Long userId) {
        // 1. è·å–æµç¨‹å®šä¹‰
        ProcessDefinition processDefinition = processDefinitionRepository
            .findByKeyAndStatus(processKey, Status.ACTIVE)
            .orElseThrow(() -> new ProcessDefinitionNotFoundException("Process definition not found"));
        
        // 2. éªŒè¯å¯åŠ¨æƒé™
        if (!canStartProcess(processDefinition, userId)) {
            throw new ProcessAccessDeniedException("Access denied");
        }
        
        // 3. å¯åŠ¨æµç¨‹å®ä¾‹
        ProcessInstance processInstance = ProcessInstance.create(
            processDefinition.getId(),
            processKey,
            request.getBusinessKey(),
            userId
        );
        
        processInstance.setVariables(request.getVariables());
        processInstance = processInstanceRepository.save(processInstance);
        
        // 4. å¯åŠ¨BPMNæµç¨‹
        ProcessInstance bpmnInstance = processEngine.startProcess(
            processKey,
            processInstance.getProcessInstanceId(),
            request.getVariables()
        );
        
        // 5. åˆ›å»ºåˆå§‹ä»»åŠ¡
        List<Task> bpmnTasks = processEngine.getActiveTasks(bpmnInstance.getId());
        for (Task bpmnTask : bpmnTasks) {
            TaskInstance taskInstance = TaskInstance.create(
                bpmnTask.getId(),
                processInstance.getProcessInstanceId(),
                bpmnTask.getName(),
                bpmnTask.getAssignee()
            );
            
            taskInstance.setVariables(bpmnTask.getVariables());
            taskInstanceRepository.save(taskInstance);
        }
        
        // 6. å‘å¸ƒäº‹ä»¶
        eventPublisher.publishEvent(new ProcessStartedEvent(processInstance.getId()));
        
        return processInstance;
    }
    
    @Override
    public TaskInstance completeTask(String taskId, CompleteTaskRequest request, Long userId) {
        // 1. è·å–ä»»åŠ¡å®ä¾‹
        TaskInstance taskInstance = taskInstanceRepository.findByTaskId(taskId)
            .orElseThrow(() -> new TaskNotFoundException("Task not found"));
        
        // 2. æ£€æŸ¥ä»»åŠ¡çŠ¶æ€
        if (!taskInstance.isActive()) {
            throw new TaskNotActiveException("Task is not active");
        }
        
        // 3. æ£€æŸ¥æƒé™
        if (!taskInstance.canComplete(userId)) {
            throw new TaskAccessDeniedException("Access denied");
        }
        
        // 4. å®Œæˆä»»åŠ¡
        taskInstance.complete(request.getVariables());
        taskInstance.setCompletionTime(LocalDateTime.now());
        taskInstanceRepository.save(taskInstance);
        
        // 5. å®ŒæˆBPMNä»»åŠ¡
        processEngine.completeTask(taskId, request.getVariables());
        
        // 6. æ£€æŸ¥æµç¨‹æ˜¯å¦å®Œæˆ
        ProcessInstance processInstance = processInstanceRepository
            .findByProcessInstanceId(taskInstance.getProcessInstanceId());
        
        if (processEngine.isProcessCompleted(processInstance.getProcessInstanceId())) {
            processInstance.complete();
            processInstanceRepository.save(processInstance);
            
            eventPublisher.publishEvent(new ProcessCompletedEvent(processInstance.getId()));
        } else {
            // åˆ›å»ºä¸‹ä¸€ä¸ªä»»åŠ¡
            List<Task> nextTasks = processEngine.getActiveTasks(processInstance.getProcessInstanceId());
            for (Task nextTask : nextTasks) {
                TaskInstance nextTaskInstance = TaskInstance.create(
                    nextTask.getId(),
                    processInstance.getProcessInstanceId(),
                    nextTask.getName(),
                    nextTask.getAssignee()
                );
                
                nextTaskInstance.setVariables(nextTask.getVariables());
                taskInstanceRepository.save(nextTaskInstance);
                
                eventPublisher.publishEvent(new TaskCreatedEvent(nextTaskInstance.getId()));
            }
        }
        
        // 7. å‘å¸ƒä»»åŠ¡å®Œæˆäº‹ä»¶
        eventPublisher.publishEvent(new TaskCompletedEvent(taskInstance.getId()));
        
        return taskInstance;
    }
}
```

## ğŸ“¨ é€šçŸ¥API

### 1. å®æ—¶é€šçŸ¥æ¥å£

#### 1.1 WebSocketè¿æ¥

```javascript
// WebSocketè¿æ¥ç¤ºä¾‹
const socket = new WebSocket('ws://localhost:8080/ws/notifications');

// è¿æ¥å»ºç«‹
socket.onopen = function(event) {
    console.log('WebSocket connected');
    
    // å‘é€è®¤è¯æ¶ˆæ¯
    socket.send(JSON.stringify({
        type: 'auth',
        data: {
            token: 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...'
        }
    }));
};

// æ¥æ”¶æ¶ˆæ¯
socket.onmessage = function(event) {
    const message = JSON.parse(event.data);
    
    switch (message.type) {
        case 'notification':
            handleNotification(message.data);
            break;
        case 'document_update':
            handleDocumentUpdate(message.data);
            break;
        case 'workflow_update':
            handleWorkflowUpdate(message.data);
            break;
    }
};

// å¤„ç†é€šçŸ¥æ¶ˆæ¯
function handleNotification(data) {
    const notification = {
        id: data.id,
        title: data.title,
        message: data.message,
        type: data.type,
        createdAt: data.createdAt,
        read: data.read
    };
    
    // æ˜¾ç¤ºé€šçŸ¥
    showNotification(notification);
    
    // æ›´æ–°é€šçŸ¥åˆ—è¡¨
    updateNotificationList(notification);
}

// å‘é€å¿ƒè·³
setInterval(() => {
    socket.send(JSON.stringify({ type: 'ping' }));
}, 30000);
```

**WebSocketå¤„ç†å™¨å®ç°**:

```java
@Component
public class NotificationWebSocketHandler extends TextWebSocketHandler {
    
    @Autowired
    private JwtTokenProvider tokenProvider;
    
    @Autowired
    private NotificationService notificationService;
    
    private final Map<String, WebSocketSession> sessions = new ConcurrentHashMap<>();
    private final Map<String, Long> userSessions = new ConcurrentHashMap<>();
    
    @Override
    public void afterConnectionEstablished(WebSocketSession session) throws Exception {
        String sessionId = session.getId();
        sessions.put(sessionId, session);
        
        log.info("WebSocket connection established: {}", sessionId);
    }
    
    @Override
    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
        try {
            JsonObject jsonMessage = JsonParser.parseString(message.getPayload()).getAsJsonObject();
            String type = jsonMessage.get("type").getAsString();
            
            switch (type) {
                case "auth":
                    handleAuth(session, jsonMessage);
                    break;
                case "ping":
                    handlePing(session);
                    break;
                default:
                    log.warn("Unknown message type: {}", type);
            }
        } catch (Exception e) {
            log.error("Error handling message: {}", message.getPayload(), e);
            sendErrorMessage(session, "Invalid message format");
        }
    }
    
    private void handleAuth(WebSocketSession session, JsonObject message) {
        try {
            String token = message.getAsJsonObject("data")
                .get("token").getAsString()
                .replace("Bearer ", "");
            
            // éªŒè¯Token
            if (tokenProvider.validateToken(token)) {
                Long userId = tokenProvider.getUserIdFromToken(token);
                String sessionId = session.getId();
                
                userSessions.put(sessionId, userId);
                
                // å‘é€è®¤è¯æˆåŠŸæ¶ˆæ¯
                sendMessage(session, new AuthMessage(true));
                
                // å‘é€æœªè¯»é€šçŸ¥
                List<Notification> unreadNotifications = notificationService.getUnreadNotifications(userId);
                for (Notification notification : unreadNotifications) {
                    sendMessage(session, new NotificationMessage(notification));
                }
                
                log.info("User {} authenticated for WebSocket session {}", userId, sessionId);
            } else {
                sendErrorMessage(session, "Invalid token");
                session.close();
            }
        } catch (Exception e) {
            log.error("Authentication failed", e);
            sendErrorMessage(session, "Authentication failed");
            session.close();
        }
    }
    
    private void handlePing(WebSocketSession session) {
        sendMessage(session, new PingMessage());
    }
    
    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
        String sessionId = session.getId();
        sessions.remove(sessionId);
        userSessions.remove(sessionId);
        
        log.info("WebSocket connection closed: {}", sessionId);
    }
    
    public void sendNotificationToUser(Long userId, Notification notification) {
        userSessions.entrySet().stream()
            .filter(entry -> entry.getValue().equals(userId))
            .forEach(entry -> {
                WebSocketSession session = sessions.get(entry.getKey());
                if (session != null && session.isOpen()) {
                    sendMessage(session, new NotificationMessage(notification));
                }
            });
    }
    
    private void sendMessage(WebSocketSession session, Object message) {
        try {
            String jsonMessage = objectMapper.writeValueAsString(message);
            session.sendMessage(new TextMessage(jsonMessage));
        } catch (Exception e) {
            log.error("Error sending message to session {}", session.getId(), e);
        }
    }
    
    private void sendErrorMessage(WebSocketSession session, String error) {
        sendMessage(session, new ErrorMessage(error));
    }
}
```

## ğŸ“ æ–‡ä»¶ä¸Šä¼ API

### 1. æ–‡ä»¶ä¸Šä¼ æ¥å£

#### 1.1 å•æ–‡ä»¶ä¸Šä¼ 

```yaml
# æ–‡ä»¶ä¸Šä¼ æ¥å£
POST /api/v1/files/upload
Authorization: Bearer {accessToken}
Content-Type: multipart/form-data

# è¯·æ±‚ä½“
file: [binary data]
category: "document"
description: "é¡¹ç›®æ–‡æ¡£"

# å“åº”ä½“
{
  "code": 200,
  "message": "File uploaded successfully",
  "data": {
    "id": "file_123456789",
    "originalName": "project-document.pdf",
    "fileName": "20231224_abc123.pdf",
    "contentType": "application/pdf",
    "size": 2048576,
    "url": "https://example.com/files/20231224_abc123.pdf",
    "thumbnailUrl": "https://example.com/thumbnails/20231224_abc123.jpg",
    "category": "document",
    "description": "é¡¹ç›®æ–‡æ¡£",
    "uploadedBy": 1,
    "uploadedAt": "2023-12-24T10:00:00Z"
  },
  "timestamp": 1703424000000
}
```

**æ–‡ä»¶ä¸Šä¼ æœåŠ¡å®ç°**:

```java
@Service
public class FileUploadServiceImpl implements FileUploadService {
    
    @Autowired
    private FileStorageService fileStorageService;
    
    @Autowired
    private ImageProcessingService imageProcessingService;
    
    @Override
    public FileUploadResult uploadFile(MultipartFile file, String category, String description, Long userId) {
        // 1. éªŒè¯æ–‡ä»¶
        validateFile(file);
        
        // 2. ç”Ÿæˆæ–‡ä»¶å
        String originalName = file.getOriginalFilename();
        String fileName = generateFileName(originalName);
        
        // 3. å­˜å‚¨æ–‡ä»¶
        String fileUrl = fileStorageService.store(file, fileName);
        
        // 4. ç”Ÿæˆç¼©ç•¥å›¾ï¼ˆå¦‚æœæ˜¯å›¾ç‰‡ï¼‰
        String thumbnailUrl = null;
        if (isImageFile(file.getContentType())) {
            thumbnailUrl = generateThumbnail(file, fileName);
        }
        
        // 5. ä¿å­˜æ–‡ä»¶è®°å½•
        FileUpload fileUpload = FileUpload.create(
            originalName,
            fileName,
            file.getContentType(),
            file.getSize(),
            fileUrl,
            thumbnailUrl,
            category,
            description,
            userId
        );
        
        fileUpload = fileUploadRepository.save(fileUpload);
        
        // 6. è¿”å›ç»“æœ
        return FileUploadResult.builder()
            .id(fileUpload.getId())
            .originalName(originalName)
            .fileName(fileName)
            .contentType(file.getContentType())
            .size(file.getSize())
            .url(fileUrl)
            .thumbnailUrl(thumbnailUrl)
            .category(category)
            .description(description)
            .uploadedBy(userId)
            .uploadedAt(fileUpload.getCreatedAt())
            .build();
    }
    
    private void validateFile(MultipartFile file) {
        if (file.isEmpty()) {
            throw new InvalidFileException("File is empty");
        }
        
        // æ£€æŸ¥æ–‡ä»¶å¤§å°
        if (file.getSize() > MAX_FILE_SIZE) {
            throw new FileSizeExceededException("File size exceeds limit");
        }
        
        // æ£€æŸ¥æ–‡ä»¶ç±»å‹
        String contentType = file.getContentType();
        if (!ALLOWED_CONTENT_TYPES.contains(contentType)) {
            throw new UnsupportedFileTypeException("File type not supported");
        }
    }
    
    private String generateFileName(String originalName) {
        String extension = getFileExtension(originalName);
        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
        String randomString = UUID.randomUUID().toString().substring(0, 8);
        
        return String.format("%s_%s.%s", timestamp, randomString, extension);
    }
    
    private String generateThumbnail(MultipartFile file, String fileName) {
        try {
            BufferedImage image = ImageIO.read(file.getInputStream());
            BufferedImage thumbnail = imageProcessingService.createThumbnail(image, 200, 200);
            
            String thumbnailName = "thumb_" + fileName.replace(".", "_thumb.");
            return fileStorageService.storeThumbnail(thumbnail, thumbnailName, "jpg");
        } catch (Exception e) {
            log.error("Failed to generate thumbnail for file: {}", fileName, e);
            return null;
        }
    }
}
```

## ğŸ”’ æ¥å£å®‰å…¨è®¾è®¡

### 1. è®¤è¯æˆæƒæœºåˆ¶

#### 1.1 JWT Tokenå®ç°

```java
@Component
public class JwtTokenProvider {
    
    @Value("${app.jwt.secret}")
    private String jwtSecret;
    
    @Value("${app.jwt.expiration}")
    private int jwtExpiration;
    
    @Value("${app.jwt.refresh-expiration}")
    private int refreshExpiration;
    
    public String generateAccessToken(User user) {
        Date expiryDate = new Date(System.currentTimeMillis() + jwtExpiration * 1000);
        
        return Jwts.builder()
            .setSubject(user.getId().toString())
            .setIssuedAt(new Date())
            .setExpiration(expiryDate)
            .claim("username", user.getUsername())
            .claim("roles", user.getRoles().stream()
                .map(role -> role.getName())
                .collect(Collectors.toList()))
            .claim("permissions", user.getPermissions())
            .signWith(SignatureAlgorithm.HS512, jwtSecret)
            .compact();
    }
    
    public String generateRefreshToken(User user) {
        Date expiryDate = new Date(System.currentTimeMillis() + refreshExpiration * 1000);
        
        return Jwts.builder()
            .setSubject(user.getId().toString())
            .setIssuedAt(new Date())
            .setExpiration(expiryDate)
            .claim("type", "refresh")
            .signWith(SignatureAlgorithm.HS512, jwtSecret)
            .compact();
    }
    
    public boolean validateToken(String token) {
        try {
            Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            log.error("Invalid JWT token: {}", e.getMessage());
            return false;
        }
    }
    
    public Long getUserIdFromToken(String token) {
        Claims claims = Jwts.parser()
            .setSigningKey(jwtSecret)
            .parseClaimsJws(token)
            .getBody();
        
        return Long.parseLong(claims.getSubject());
    }
    
    @SuppressWarnings("unchecked")
    public List<String> getRolesFromToken(String token) {
        Claims claims = Jwts.parser()
            .setSigningKey(jwtSecret)
            .parseClaimsJws(token)
            .getBody();
        
        return (List<String>) claims.get("roles");
    }
    
    @SuppressWarnings("unchecked")
    public Set<String> getPermissionsFromToken(String token) {
        Claims claims = Jwts.parser()
            .setSigningKey(jwtSecret)
            .parseClaimsJws(token)
            .getBody();
        
        return new HashSet<>((List<String>) claims.get("permissions"));
    }
}
```

#### 1.2 æƒé™æ§åˆ¶æ‹¦æˆªå™¨

```java
@Component
public class AuthorizationInterceptor implements HandlerInterceptor {
    
    @Autowired
    private JwtTokenProvider tokenProvider;
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        if (handler instanceof HandlerMethod) {
            HandlerMethod handlerMethod = (HandlerMethod) handler;
            
            // æ£€æŸ¥æ–¹æ³•çº§åˆ«çš„æƒé™æ³¨è§£
            PreAuthorize preAuthorize = handlerMethod.getMethodAnnotation(PreAuthorize.class);
            if (preAuthorize != null) {
                return checkPermission(request, preAuthorize.value());
            }
            
            // æ£€æŸ¥ç±»çº§åˆ«çš„æƒé™æ³¨è§£
            preAuthorize = handlerMethod.getBeanType().getAnnotation(PreAuthorize.class);
            if (preAuthorize != null) {
                return checkPermission(request, preAuthorize.value());
            }
        }
        
        return true;
    }
    
    private boolean checkPermission(HttpServletRequest request, String expression) {
        try {
            // è·å–Token
            String token = extractToken(request);
            if (token == null) {
                return false;
            }
            
            // éªŒè¯Token
            if (!tokenProvider.validateToken(token)) {
                return false;
            }
            
            // è·å–ç”¨æˆ·æƒé™
            Set<String> permissions = tokenProvider.getPermissionsFromToken(token);
            
            // è¯„ä¼°æƒé™è¡¨è¾¾å¼
            return evaluatePermissionExpression(expression, permissions);
            
        } catch (Exception e) {
            log.error("Permission check failed", e);
            return false;
        }
    }
    
    private String extractToken(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
    
    private boolean evaluatePermissionExpression(String expression, Set<String> permissions) {
        // ç®€å•çš„æƒé™è¡¨è¾¾å¼è¯„ä¼°
        if (expression.equals("isAuthenticated()")) {
            return true;
        }
        
        if (expression.startsWith("hasRole('") && expression.endsWith("')")) {
            String role = expression.substring(9, expression.length() - 2);
            return permissions.contains(role);
        }
        
        if (expression.startsWith("hasAuthority('") && expression.endsWith("')")) {
            String permission = expression.substring(14, expression.length() - 2);
            return permissions.contains(permission);
        }
        
        // æ›´å¤æ‚çš„è¡¨è¾¾å¼å¯ä»¥ä½¿ç”¨SpELç­‰è¡¨è¾¾å¼å¼•æ“
        return false;
    }
}
```

### 2. æ¥å£é™æµç†”æ–­

#### 2.1 é™æµå®ç°

```java
@Component
public class RateLimitingInterceptor implements HandlerInterceptor {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    private static final String RATE_LIMIT_PREFIX = "rate_limit:";
    private static final int DEFAULT_LIMIT = 100; // æ¯åˆ†é’Ÿ100æ¬¡è¯·æ±‚
    private static final int DEFAULT_WINDOW = 60; // 60ç§’çª—å£
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        String clientIp = getClientIp(request);
        String uri = request.getRequestURI();
        String key = RATE_LIMIT_PREFIX + clientIp + ":" + uri;
        
        // æ£€æŸ¥é™æµ
        if (!isAllowed(key, DEFAULT_LIMIT, DEFAULT_WINDOW)) {
            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());
            response.getWriter().write("{\"error\":\"Rate limit exceeded\"}");
            return false;
        }
        
        return true;
    }
    
    private boolean isAllowed(String key, int limit, int window) {
        String script = "local current = redis.call('get', KEYS[1]) " +
                      "if current and tonumber(current) > tonumber(ARGV[1]) " +
                      "then return 0 " +
                      "end " +
                      "redis.call('incr', KEYS[1]) " +
                      "if tonumber(redis.call('get', KEYS[1])) == 1 " +
                      "then redis.call('expire', KEYS[1], ARGV[2]) " +
                      "end " +
                      "return 1";
        
        Long result = redisTemplate.execute(
            new DefaultRedisScript<>(script, Long.class),
            Collections.singletonList(key),
            String.valueOf(limit),
            String.valueOf(window)
        );
        
        return result != null && result == 1;
    }
    
    private String getClientIp(HttpServletRequest request) {
        String xForwardedFor = request.getHeader("X-Forwarded-For");
        if (xForwardedFor != null && !xForwardedFor.isEmpty()) {
            return xForwardedFor.split(",")[0].trim();
        }
        
        String xRealIp = request.getHeader("X-Real-IP");
        if (xRealIp != null && !xRealIp.isEmpty()) {
            return xRealIp;
        }
        
        return request.getRemoteAddr();
    }
}
```

---

*æœ¬æ–‡æ¡£æä¾›äº†è¯¦ç»†çš„æ¥å£è®¾è®¡ï¼ŒåŒ…æ‹¬REST APIã€GraphQLã€WebSocketå’Œæ–‡ä»¶ä¸Šä¼ çš„å…·ä½“å®ç°ï¼Œä¸ºå¼€å‘å›¢é˜Ÿæä¾›äº†å®Œæ•´çš„APIå¼€å‘æŒ‡å¯¼ã€‚*