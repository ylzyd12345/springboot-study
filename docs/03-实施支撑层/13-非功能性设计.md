# Junmo Platform éåŠŸèƒ½æ€§è®¾è®¡

## ğŸ“‹ æ–‡æ¡£ä¿¡æ¯

| é¡¹ç›® | å†…å®¹ |
|------|------|
| **æ–‡æ¡£åç§°** | Junmo Platform éåŠŸèƒ½æ€§è®¾è®¡ |
| **ç‰ˆæœ¬å·** | v1.1.0 |
| **åˆ›å»ºæ—¥æœŸ** | 2025-12-24 |
| **æ›´æ–°æ—¥æœŸ** | 2026-01-07 |
| **ä½œè€…** | ç³»ç»Ÿæ¶æ„å¸ˆ |
| **å®¡æ ¸äºº** | è´¨é‡ä¿è¯ç»ç† |
| **æ‰¹å‡†äºº** | æŠ€æœ¯æ€»ç›‘ |

## ğŸ“ æ›´æ–°è¯´æ˜

**v1.1.0 (2026-01-07)**:
- è®¤è¯æ¡†æ¶ä»Spring Securityè°ƒæ•´ä¸ºSa-Token

## ğŸ¯ éåŠŸèƒ½æ€§è®¾è®¡æ¦‚è¿°

Junmo Platformçš„éåŠŸèƒ½æ€§è®¾è®¡æ¶µç›–äº†æ€§èƒ½ã€å¯ç”¨æ€§ã€å®‰å…¨æ€§ã€å¯ç»´æŠ¤æ€§ã€å¯æ‰©å±•æ€§ç­‰å…³é”®è´¨é‡å±æ€§ã€‚é€šè¿‡ç³»ç»Ÿæ€§çš„è®¾è®¡å’Œå®ç°ï¼Œç¡®ä¿ç³»ç»Ÿåœ¨å„ç§è´Ÿè½½æ¡ä»¶ä¸‹éƒ½èƒ½ç¨³å®šè¿è¡Œï¼ŒåŒæ—¶æ»¡è¶³ä¸šåŠ¡å‘å±•çš„éœ€æ±‚ã€‚

## âš¡ æ€§èƒ½è®¾è®¡

### 1. æ€§èƒ½ç›®æ ‡ä¸æŒ‡æ ‡

**æ€§èƒ½æŒ‡æ ‡å®šä¹‰**:

```yaml
# æ€§èƒ½ç›®æ ‡
performance_targets:
  response_time:
    api_endpoints:
      - endpoint: "/api/v1/users"
        target: "< 200ms"
        measurement: "95th percentile"
      - endpoint: "/api/v1/documents/search"
        target: "< 500ms"
        measurement: "95th percentile"
      - endpoint: "/api/v1/auth/login"
        target: "< 300ms"
        measurement: "95th percentile"
    
    web_pages:
      - page: "dashboard"
        target: "< 2s"
        measurement: "page load time"
      - page: "document_list"
        target: "< 1.5s"
        measurement: "page load time"
  
  throughput:
    concurrent_users: "> 1000"
    requests_per_second: "> 5000"
    database_transactions: "> 10000"
  
  resource_utilization:
    cpu_usage: "< 70%"
    memory_usage: "< 80%"
    disk_io: "< 80%"
    network_io: "< 70%"
```

### 2. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

#### 2.1 åº”ç”¨å±‚ä¼˜åŒ–

**ç¼“å­˜ç­–ç•¥å®ç°**:

```java
@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        // å¤šçº§ç¼“å­˜ç®¡ç†å™¨
        CompositeCacheManager compositeCacheManager = new CompositeCacheManager();
        
        // L1ç¼“å­˜ï¼šæœ¬åœ°ç¼“å­˜
        CaffeineCacheManager caffeineCacheManager = new CaffeineCacheManager();
        caffeineCacheManager.setCaffeine(Caffeine.newBuilder()
            .maximumSize(1000)
            .expireAfterWrite(Duration.ofMinutes(10))
            .recordStats());
        
        // L2ç¼“å­˜ï¼šåˆ†å¸ƒå¼ç¼“å­˜
        RedisCacheManager redisCacheManager = RedisCacheManager
            .builder(redisConnectionFactory())
            .cacheDefaults(redisCacheConfiguration())
            .build();
        
        compositeCacheManager.setCacheManagers(Arrays.asList(
            caffeineCacheManager,
            redisCacheManager
        ));
        
        return compositeCacheManager;
    }
    
    private RedisCacheConfiguration redisCacheConfiguration() {
        return RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(30))
            .serializeKeysWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new GenericJackson2JsonRedisSerializer()))
            .disableCachingNullValues();
    }
}

// ç¼“å­˜ä½¿ç”¨ç¤ºä¾‹
@Service
public class UserServiceImpl implements UserService {
    
    @Cacheable(value = "users", key = "#userId", unless = "#result == null")
    public UserDTO getUserById(Long userId) {
        User user = userRepository.findById(userId).orElse(null);
        return user != null ? UserMapper.toDTO(user) : null;
    }
    
    @CacheEvict(value = "users", key = "#userId")
    public void updateUser(Long userId, UpdateUserRequest request) {
        // æ›´æ–°ç”¨æˆ·é€»è¾‘
    }
    
    @Cacheable(value = "user_permissions", key = "#userId")
    public Set<String> getUserPermissions(Long userId) {
        return userRepository.findPermissionsByUserId(userId);
    }
}
```

**å¼‚æ­¥å¤„ç†æœºåˆ¶**:

```java
@Configuration
@EnableAsync
public class AsyncConfig {
    
    @Bean(name = "taskExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(20);
        executor.setQueueCapacity(200);
        executor.setThreadNamePrefix("Async-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.setWaitForTasksToCompleteOnShutdown(true);
        executor.setAwaitTerminationSeconds(60);
        executor.initialize();
        return executor;
    }
    
    @Bean(name = "emailExecutor")
    public Executor emailExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("Email-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());
        executor.initialize();
        return executor;
    }
}

// å¼‚æ­¥æœåŠ¡ç¤ºä¾‹
@Service
public class NotificationServiceImpl implements NotificationService {
    
    @Async("emailExecutor")
    public CompletableFuture<Void> sendEmail(String to, String subject, String content) {
        try {
            emailService.send(to, subject, content);
            log.info("Email sent successfully to: {}", to);
            return CompletableFuture.completedFuture(null);
        } catch (Exception e) {
            log.error("Failed to send email to: {}", to, e);
            return CompletableFuture.failedFuture(e);
        }
    }
    
    @Async("taskExecutor")
    public CompletableFuture<Void> processDocumentAsync(Long documentId) {
        try {
            documentProcessor.process(documentId);
            return CompletableFuture.completedFuture(null);
        } catch (Exception e) {
            log.error("Failed to process document: {}", documentId, e);
            return CompletableFuture.failedFuture(e);
        }
    }
}
```

#### 2.2 æ•°æ®åº“ä¼˜åŒ–

**è¿æ¥æ± é…ç½®**:

```yaml
# æ•°æ®åº“è¿æ¥æ± é…ç½®
spring:
  datasource:
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      idle-timeout: 300000
      max-lifetime: 1200000
      connection-timeout: 20000
      leak-detection-threshold: 60000
      connection-test-query: SELECT 1
      
  jpa:
    hibernate:
      ddl-auto: validate
      naming:
        physical-strategy: org.hibernate.boot.model.naming.SnakeCasePhysicalNamingStrategy
    show-sql: false
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MySQL8Dialect
        format_sql: true
        use_sql_comments: true
        jdbc:
          batch_size: 20
          order_inserts: true
          order_updates: true
        cache:
          use_second_level_cache: true
          use_query_cache: true
          region.factory_class: org.hibernate.cache.ehcache.EhCacheRegionFactory
```

**æŸ¥è¯¢ä¼˜åŒ–ç¤ºä¾‹**:

```java
@Repository
public class UserRepositoryImpl implements UserRepositoryCustom {
    
    @Autowired
    private EntityManager entityManager;
    
    /**
     * ä¼˜åŒ–çš„ç”¨æˆ·æŸ¥è¯¢
     */
    @Override
    public Page<UserDTO> findUsersOptimized(UserQuery query, Pageable pageable) {
        CriteriaBuilder cb = entityManager.getCriteriaBuilder();
        CriteriaQuery<User> cq = cb.createQuery(User.class);
        Root<User> root = cq.from(User.class);
        
        // æ„å»ºæŸ¥è¯¢æ¡ä»¶
        List<Predicate> predicates = new ArrayList<>();
        
        if (StringUtils.hasText(query.getKeyword())) {
            Predicate usernamePredicate = cb.like(
                cb.lower(root.get("username")), 
                "%" + query.getKeyword().toLowerCase() + "%"
            );
            Predicate emailPredicate = cb.like(
                cb.lower(root.get("email")), 
                "%" + query.getKeyword().toLowerCase() + "%"
            );
            predicates.add(cb.or(usernamePredicate, emailPredicate));
        }
        
        if (query.getStatus() != null) {
            predicates.add(cb.equal(root.get("status"), query.getStatus()));
        }
        
        if (query.getRoleId() != null) {
            Join<User, UserRole> userRoleJoin = root.join("userRoles", JoinType.INNER);
            Join<UserRole, Role> roleJoin = userRoleJoin.join("role", JoinType.INNER);
            predicates.add(cb.equal(roleJoin.get("id"), query.getRoleId()));
        }
        
        cq.where(predicates.toArray(new Predicate[0]));
        
        // æ‰§è¡ŒæŸ¥è¯¢
        TypedQuery<User> typedQuery = entityManager.createQuery(cq);
        typedQuery.setFirstResult((int) pageable.getOffset());
        typedQuery.setMaxResults(pageable.getPageSize());
        
        List<User> users = typedQuery.getResultList();
        
        // è·å–æ€»æ•°
        CriteriaQuery<Long> countQuery = cb.createQuery(Long.class);
        Root<User> countRoot = countQuery.from(User.class);
        countQuery.select(cb.count(countRoot));
        countQuery.where(predicates.toArray(new Predicate[0]));
        
        Long total = entityManager.createQuery(countQuery).getSingleResult();
        
        // è½¬æ¢ä¸ºDTO
        List<UserDTO> userDTOs = users.stream()
            .map(UserMapper::toDTO)
            .collect(Collectors.toList());
        
        return new PageImpl<>(userDTOs, pageable, total);
    }
}
```

### 3. æ€§èƒ½ç›‘æ§

#### 3.1 æŒ‡æ ‡æ”¶é›†

**è‡ªå®šä¹‰æŒ‡æ ‡**:

```java
@Component
public class PerformanceMetrics {
    
    private final MeterRegistry meterRegistry;
    private final Counter requestCounter;
    private final Timer responseTimer;
    private final Gauge activeConnections;
    
    public PerformanceMetrics(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        
        this.requestCounter = Counter.builder("http.requests.total")
            .description("Total number of HTTP requests")
            .register(meterRegistry);
        
        this.responseTimer = Timer.builder("http.request.duration")
            .description("HTTP request duration")
            .register(meterRegistry);
        
        this.activeConnections = Gauge.builder("http.connections.active")
            .description("Number of active HTTP connections")
            .register(meterRegistry, this, PerformanceMetrics::getActiveConnections);
    }
    
    public void recordRequest(String method, String uri, int statusCode, long duration) {
        // å¢åŠ è¯·æ±‚è®¡æ•°
        requestCounter.increment(
            Tags.of(
                Tag.of("method", method),
                Tag.of("uri", uri),
                Tag.of("status", String.valueOf(statusCode))
            )
        );
        
        // è®°å½•å“åº”æ—¶é—´
        responseTimer.record(duration, TimeUnit.MILLISECONDS,
            Tags.of(
                Tag.of("method", method),
                Tag.of("uri", uri)
            )
        );
    }
    
    private double getActiveConnections() {
        // å®ç°è·å–æ´»è·ƒè¿æ¥æ•°çš„é€»è¾‘
        return 0.0;
    }
}

// æ€§èƒ½æ‹¦æˆªå™¨
@Component
public class PerformanceInterceptor implements HandlerInterceptor {
    
    @Autowired
    private PerformanceMetrics performanceMetrics;
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        request.setAttribute("startTime", System.currentTimeMillis());
        return true;
    }
    
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, 
            Object handler, Exception ex) {
        
        long startTime = (Long) request.getAttribute("startTime");
        long duration = System.currentTimeMillis() - startTime;
        
        performanceMetrics.recordRequest(
            request.getMethod(),
            request.getRequestURI(),
            response.getStatus(),
            duration
        );
    }
}
```

#### 3.2 æ€§èƒ½åˆ†æå·¥å…·

**æ€§èƒ½åˆ†ææœåŠ¡**:

```java
@Service
public class PerformanceAnalysisService {
    
    @Autowired
    private MeterRegistry meterRegistry;
    
    /**
     * è·å–æ€§èƒ½ç»Ÿè®¡
     */
    public PerformanceStats getPerformanceStats() {
        PerformanceStats stats = new PerformanceStats();
        
        // è·å–è¯·æ±‚ç»Ÿè®¡
        stats.setRequestCount(getRequestCount());
        stats.setAverageResponseTime(getAverageResponseTime());
        stats.setErrorRate(getErrorRate());
        
        // è·å–ç³»ç»Ÿèµ„æºä½¿ç”¨æƒ…å†µ
        stats.setCpuUsage(getCpuUsage());
        stats.setMemoryUsage(getMemoryUsage());
        stats.setDiskUsage(getDiskUsage());
        
        // è·å–æ•°æ®åº“æ€§èƒ½
        stats.setDatabaseConnectionPool(getDatabaseConnectionPoolStats());
        stats.setDatabaseQueryTime(getDatabaseQueryTime());
        
        return stats;
    }
    
    private long getRequestCount() {
        return meterRegistry.get("http.requests.total").counter().count();
    }
    
    private double getAverageResponseTime() {
        return meterRegistry.get("http.request.duration").timer().mean(TimeUnit.MILLISECONDS);
    }
    
    private double getErrorRate() {
        double totalRequests = meterRegistry.get("http.requests.total").counter().count();
        double errorRequests = meterRegistry.get("http.requests.total")
            .tag("status", "5").counter().count();
        
        return totalRequests > 0 ? (errorRequests / totalRequests) * 100 : 0.0;
    }
    
    private double getCpuUsage() {
        OperatingSystemMXBean osBean = ManagementFactory.getOperatingSystemMXBean();
        return osBean.getSystemLoadAverage() * 100;
    }
    
    private double getMemoryUsage() {
        MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
        MemoryUsage heapUsage = memoryBean.getHeapMemoryUsage();
        return (double) heapUsage.getUsed() / heapUsage.getMax() * 100;
    }
    
    private double getDiskUsage() {
        File disk = new File("/");
        long totalSpace = disk.getTotalSpace();
        long freeSpace = disk.getFreeSpace();
        return ((double) (totalSpace - freeSpace) / totalSpace) * 100;
    }
}
```

## ğŸ›¡ï¸ å®‰å…¨æ€§è®¾è®¡

### 1. å®‰å…¨æ¶æ„

#### 1.1 è®¤è¯æˆæƒæ¶æ„

```mermaid
graph TB
    subgraph "å®¢æˆ·ç«¯"
        A1[Webå‰ç«¯] --> A2[ç§»åŠ¨ç«¯]
        A3[ç¬¬ä¸‰æ–¹åº”ç”¨]
    end
    
    subgraph "è®¤è¯å±‚"
        B1[OAuth2æœåŠ¡å™¨] --> B2[JWT TokenæœåŠ¡]
        B3[ä¼šè¯ç®¡ç†] --> B4[å¤šå› å­è®¤è¯]
    end
    
    subgraph "æˆæƒå±‚"
        C1[RBACæƒé™æ§åˆ¶] --> C2[ABACå±æ€§æ§åˆ¶]
        C3[APIæƒé™éªŒè¯] --> C4[èµ„æºæƒé™æ£€æŸ¥]
    end
    
    subgraph "å®‰å…¨é˜²æŠ¤å±‚"
        D1[é˜²ç«å¢™] --> D2[å…¥ä¾µæ£€æµ‹]
        D3[æ•°æ®åŠ å¯†] --> D4[å®‰å…¨å®¡è®¡]
    end
    
    A1 --> B1
    A2 --> B1
    A3 --> B1
    B1 --> C1
    C1 --> D1
```

#### 1.2 å®‰å…¨é…ç½®å®ç°

**Sa-Tokené…ç½®**:

```java
@Configuration
public class SaTokenConfig {

    @Bean
    public SaTokenDao saTokenDao() {
        // ä½¿ç”¨ Redis å­˜å‚¨ Token
        return new SaTokenDaoRedisImpl();
    }

    @Bean
    public StpInterface stpInterface() {
        return new StpInterfaceImpl();
    }
}

@Component
public class StpInterfaceImpl implements StpInterface {

    @Autowired
    private UserMapper userMapper;

    @Override
    public List<String> getPermissionList(Object loginId, String loginType) {
        // è¿”å›æ­¤ loginId æ‹¥æœ‰çš„æƒé™åˆ—è¡¨
        User user = userMapper.selectById((Long) loginId);
        return user.getPermissions();
    }

    @Override
    public List<String> getRoleList(Object loginId, String loginType) {
        // è¿”å›æ­¤ loginId æ‹¥æœ‰çš„è§’è‰²ç åˆ—è¡¨
        User user = userMapper.selectById((Long) loginId);
        return user.getRoles();
    }
}
    private CustomAuthenticationEntryPoint authenticationEntryPoint;
    
    @Autowired
    private CustomAccessDeniedHandler accessDeniedHandler;
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            // ç¦ç”¨CSRF
            .csrf(csrf -> csrf.disable())
            
            // é…ç½®ä¼šè¯ç®¡ç†
            .sessionManagement(session -> 
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            
            // é…ç½®å¼‚å¸¸å¤„ç†
            .exceptionHandling(exceptions -> exceptions
                .authenticationEntryPoint(authenticationEntryPoint)
                .accessDeniedHandler(accessDeniedHandler))
            
            // é…ç½®è¯·æ±‚æˆæƒ
            .authorizeHttpRequests(authz -> authz
                // å…¬å¼€æ¥å£
                .requestMatchers("/api/v1/auth/**").permitAll()
                .requestMatchers("/api/v1/public/**").permitAll()
                .requestMatchers("/actuator/health").permitAll()
                .requestMatchers("/actuator/info").permitAll()
                
                // é™æ€èµ„æº
                .requestMatchers("/static/**", "/css/**", "/js/**", "/images/**").permitAll()
                
                // ç®¡ç†å‘˜æ¥å£
                .requestMatchers("/api/v1/admin/**").hasRole("ADMIN")
                
                // å…¶ä»–æ¥å£éœ€è¦è®¤è¯
                .anyRequest().authenticated()
            )
            
            // æ·»åŠ JWTè¿‡æ»¤å™¨
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)
            
            // é…ç½®CORS
            .cors(cors -> cors.configurationSource(corsConfigurationSource()))
            
            // é…ç½®å®‰å…¨å¤´
            .headers(headers -> headers
                .contentSecurityPolicy(csp -> csp
                    .policyDirectives("default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'"))
                .frameOptions(HeadersConfigurer.FrameOptionsConfig::deny)
                .xssProtection(HeadersConfigurer.XXSSConfig::disable)
                .httpStrictTransportSecurity(hsts -> hsts
                    .includeSubDomains(true)
                    .maxAgeInSeconds(31536000))
            );
        
        return http.build();
    }
    
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOriginPatterns(Arrays.asList("*"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("*"));
        configuration.setAllowCredentials(true);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(12);
    }
    
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
}
```

### 2. æ•°æ®å®‰å…¨

#### 2.1 æ•°æ®åŠ å¯†å®ç°

**æ•æ„Ÿæ•°æ®åŠ å¯†**:

```java
@Component
public class DataEncryptionService {
    
    @Value("${app.encryption.key}")
    private String encryptionKey;
    
    private static final String ALGORITHM = "AES/CBC/PKCS5Padding";
    private static final String SECRET_KEY_ALGORITHM = "AES";
    
    /**
     * åŠ å¯†æ•æ„Ÿæ•°æ®
     */
    public String encrypt(String plainText) {
        try {
            SecretKeySpec secretKey = new SecretKeySpec(
                encryptionKey.getBytes(), SECRET_KEY_ALGORITHM);
            
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            
            byte[] encryptedBytes = cipher.doFinal(plainText.getBytes());
            return Base64.getEncoder().encodeToString(encryptedBytes);
            
        } catch (Exception e) {
            throw new EncryptionException("Failed to encrypt data", e);
        }
    }
    
    /**
     * è§£å¯†æ•æ„Ÿæ•°æ®
     */
    public String decrypt(String encryptedText) {
        try {
            SecretKeySpec secretKey = new SecretKeySpec(
                encryptionKey.getBytes(), SECRET_KEY_ALGORITHM);
            
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            cipher.init(Cipher.DECRYPT_MODE, secretKey);
            
            byte[] decryptedBytes = cipher.doFinal(
                Base64.getDecoder().decode(encryptedText));
            return new String(decryptedBytes);
            
        } catch (Exception e) {
            throw new EncryptionException("Failed to decrypt data", e);
        }
    }
}

// æ•æ„Ÿå­—æ®µå¤„ç†
@Converter
public class EncryptedStringConverter implements AttributeConverter<String, String> {
    
    @Autowired
    private DataEncryptionService encryptionService;
    
    @Override
    public String convertToDatabaseColumn(String attribute) {
        return attribute != null ? encryptionService.encrypt(attribute) : null;
    }
    
    @Override
    public String convertToEntityAttribute(String dbData) {
        return dbData != null ? encryptionService.decrypt(dbData) : null;
    }
}
```

#### 2.2 SQLæ³¨å…¥é˜²æŠ¤

**å®‰å…¨æŸ¥è¯¢å®ç°**:

```java
@Repository
public class SecureUserRepository {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    /**
     * å®‰å…¨çš„ç”¨æˆ·æŸ¥è¯¢ - ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢
     */
    public List<User> findUsersByCriteria(String username, String email, UserStatus status) {
        StringBuilder sql = new StringBuilder("SELECT * FROM users WHERE 1=1");
        List<Object> params = new ArrayList<>();
        
        if (StringUtils.hasText(username)) {
            sql.append(" AND username = ?");
            params.add(username);
        }
        
        if (StringUtils.hasText(email)) {
            sql.append(" AND email = ?");
            params.add(email);
        }
        
        if (status != null) {
            sql.append(" AND status = ?");
            params.add(status.name());
        }
        
        return jdbcTemplate.query(sql.toString(), 
            params.toArray(), 
            new UserRowMapper());
    }
    
    /**
     * ä½¿ç”¨å­˜å‚¨è¿‡ç¨‹é˜²æ­¢SQLæ³¨å…¥
     */
    public List<User> searchUsers(String keyword) {
        SimpleJdbcCall jdbcCall = new SimpleJdbcCall(jdbcTemplate)
            .withProcedureName("search_users")
            .returningResultSet("users", new UserRowMapper());
        
        SqlParameterSource in = new MapSqlParameterSource()
            .addValue("p_keyword", keyword);
        
        Map<String, Object> result = jdbcCall.execute(in);
        return (List<User>) result.get("users");
    }
}

// è¾“å…¥éªŒè¯ç»„ä»¶
@Component
public class InputValidator {
    
    private static final Pattern SQL_INJECTION_PATTERN = 
        Pattern.compile("(?i)(union|select|insert|update|delete|drop|create|alter|exec|execute)");
    
    /**
     * æ£€æŸ¥SQLæ³¨å…¥
     */
    public boolean containsSqlInjection(String input) {
        if (input == null || input.trim().isEmpty()) {
            return false;
        }
        return SQL_INJECTION_PATTERN.matcher(input).find();
    }
    
    /**
     * æ¸…ç†è¾“å…¥
     */
    public String sanitizeInput(String input) {
        if (input == null) {
            return null;
        }
        
        // ç§»é™¤å±é™©å­—ç¬¦
        return input.replaceAll("[';\"\\\\]", "");
    }
}
```

### 3. å®‰å…¨ç›‘æ§

#### 3.1 å®‰å…¨äº‹ä»¶ç›‘æ§

**å®‰å…¨äº‹ä»¶å¤„ç†**:

```java
@Component
public class SecurityEventMonitor {
    
    @Autowired
    private SecurityEventRepository securityEventRepository;
    
    @Autowired
    private NotificationService notificationService;
    
    /**
     * è®°å½•å®‰å…¨äº‹ä»¶
     */
    public void recordSecurityEvent(SecurityEvent event) {
        // ä¿å­˜äº‹ä»¶
        securityEventRepository.save(event);
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦å‘Šè­¦
        if (requiresAlert(event)) {
            sendSecurityAlert(event);
        }
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦è‡ªåŠ¨å“åº”
        if (requiresAutoResponse(event)) {
            executeAutoResponse(event);
        }
    }
    
    @EventListener
    public void handleAuthenticationFailure(AuthenticationFailureEvent event) {
        SecurityEvent securityEvent = SecurityEvent.builder()
            .eventType("AUTHENTICATION_FAILURE")
            .username(event.getUsername())
            .ipAddress(event.getIpAddress())
            .userAgent(event.getUserAgent())
            .description("Authentication failed for user: " + event.getUsername())
            .severity("HIGH")
            .timestamp(LocalDateTime.now())
            .build();
        
        recordSecurityEvent(securityEvent);
    }
    
    @EventListener
    public void handleSuspiciousActivity(SuspiciousActivityEvent event) {
        SecurityEvent securityEvent = SecurityEvent.builder()
            .eventType("SUSPICIOUS_ACTIVITY")
            .ipAddress(event.getIpAddress())
            .description(event.getDescription())
            .severity("CRITICAL")
            .timestamp(LocalDateTime.now())
            .build();
        
        recordSecurityEvent(securityEvent);
    }
    
    private boolean requiresAlert(SecurityEvent event) {
        return "CRITICAL".equals(event.getSeverity()) || 
               "HIGH".equals(event.getSeverity());
    }
    
    private void sendSecurityAlert(SecurityEvent event) {
        SecurityAlert alert = SecurityAlert.builder()
            .title("Security Alert: " + event.getEventType())
            .message(event.getDescription())
            .severity(event.getSeverity())
            .timestamp(LocalDateTime.now())
            .build();
        
        notificationService.sendSecurityAlert(alert);
    }
    
    private void requiresAutoResponse(SecurityEvent event) {
        return "CRITICAL".equals(event.getSeverity());
    }
    
    private void executeAutoResponse(SecurityEvent event) {
        switch (event.getEventType()) {
            case "SUSPICIOUS_ACTIVITY":
                blockIpAddress(event.getIpAddress());
                break;
            case "BRUTE_FORCE_ATTACK":
                blockIpAddress(event.getIpAddress());
                break;
            default:
                break;
        }
    }
    
    private void blockIpAddress(String ipAddress) {
        // å®ç°IPåœ°å€å°ç¦é€»è¾‘
        log.warn("Blocking IP address due to suspicious activity: {}", ipAddress);
    }
}
```

## ğŸ”§ å¯ç»´æŠ¤æ€§è®¾è®¡

### 1. ä»£ç è´¨é‡ä¿è¯

#### 1.1 ä»£ç è§„èŒƒ

**ä»£ç æ£€æŸ¥é…ç½®**:

```xml
<!-- pom.xmlä¸­çš„ä»£ç è´¨é‡æ’ä»¶é…ç½® -->
<plugin>
    <groupId>com.github.spotbugs</groupId>
    <artifactId>spotbugs-maven-plugin</artifactId>
    <version>4.7.3.0</version>
    <configuration>
        <effort>Max</effort>
        <threshold>Low</threshold>
        <xmlOutput>true</xmlOutput>
    </configuration>
</plugin>

<plugin>
    <groupId>org.jacoco</groupId>
    <artifactId>jacoco-maven-plugin</artifactId>
    <version>0.8.8</version>
    <executions>
        <execution>
            <goals>
                <goal>prepare-agent</goal>
            </goals>
        </execution>
        <execution>
            <id>report</id>
            <phase>test</phase>
            <goals>
                <goal>report</goal>
            </goals>
        </execution>
    </executions>
</plugin>

<plugin>
    <groupId>org.sonarsource.scanner.maven</groupId>
    <artifactId>sonar-maven-plugin</artifactId>
    <version>3.9.1.2184</version>
</plugin>
```

**ä»£ç è´¨é‡é—¨ç¦**:

```yaml
# .github/workflows/quality-check.yml
name: Quality Check

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  quality-check:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up JDK 25
      uses: actions/setup-java@v3
      with:
        java-version: '25'
        distribution: 'temurin'
    
    - name: Cache Maven packages
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
    
    - name: Run tests
      run: mvn clean test
    
    - name: Generate test report
      uses: dorny/test-reporter@v1
      if: success() || failure()
      with:
        name: Maven Tests
        path: target/surefire-reports/*.xml
        reporter: java-junit
    
    - name: Run SpotBugs
      run: mvn spotbugs:check
    
    - name: Generate JaCoCo report
      run: mvn jacoco:report
    
    - name: Check test coverage
      run: |
        COVERAGE=$(mvn jacoco:report -q | grep -oP 'Total.*? \K[0-9]+%' | tr -d '%')
        if [ $COVERAGE -lt 80 ]; then
          echo "Test coverage is below 80%: $COVERAGE%"
          exit 1
        fi
    
    - name: SonarCloud Scan
      uses: SonarSource/sonarcloud-github-action@master
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
```

#### 1.2 æ—¥å¿—è§„èŒƒ

**æ—¥å¿—é…ç½®**:

```xml
<!-- logback-spring.xml -->
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <springProfile name="!prod">
        <include resource="org/springframework/boot/logging/logback/defaults.xml"/>
        <include resource="org/springframework/boot/logging/logback/console-appender.xml"/>
        <root level="INFO">
            <appender-ref ref="CONSOLE"/>
        </root>
    </springProfile>
    
    <springProfile name="prod">
        <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
            <file>logs/Junmo Platform.log</file>
            <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
                <fileNamePattern>logs/Junmo Platform.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
                <maxFileSize>100MB</maxFileSize>
                <maxHistory>30</maxHistory>
                <totalSizeCap>3GB</totalSizeCap>
            </rollingPolicy>
            <encoder>
                <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
            </encoder>
        </appender>
        
        <appender name="ERROR_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
            <file>logs/error.log</file>
            <filter class="ch.qos.logback.classic.filter.LevelFilter">
                <level>ERROR</level>
                <onMatch>ACCEPT</onMatch>
                <onMismatch>DENY</onMismatch>
            </filter>
            <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
                <fileNamePattern>logs/error.%d{yyyy-MM-dd}.log</fileNamePattern>
                <maxHistory>30</maxHistory>
            </rollingPolicy>
            <encoder>
                <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
            </encoder>
        </appender>
        
        <root level="INFO">
            <appender-ref ref="FILE"/>
            <appender-ref ref="ERROR_FILE"/>
        </root>
    </springProfile>
</configuration>
```

**ç»“æ„åŒ–æ—¥å¿—å®ç°**:

```java
@Component
public class StructuredLogger {
    
    private static final Logger logger = LoggerFactory.getLogger(StructuredLogger.class);
    
    /**
     * è®°å½•ç”¨æˆ·æ“ä½œæ—¥å¿—
     */
    public void logUserAction(String userId, String action, String resource, String result) {
        logger.info("USER_ACTION {} {} {} {}",
            userId, action, resource, result);
    }
    
    /**
     * è®°å½•APIè°ƒç”¨æ—¥å¿—
     */
    public void logApiCall(String method, String uri, int statusCode, long duration) {
        logger.info("API_CALL {} {} {} {}",
            method, uri, statusCode, duration);
    }
    
    /**
     * è®°å½•ä¸šåŠ¡äº‹ä»¶æ—¥å¿—
     */
    public void logBusinessEvent(String eventType, String entityId, Map<String, Object> metadata) {
        logger.info("BUSINESS_EVENT {} {} {}",
            eventType, entityId, metadata);
    }
    
    /**
     * è®°å½•é”™è¯¯æ—¥å¿—
     */
    public void logError(String message, Throwable throwable, Map<String, Object> context) {
        logger.error("ERROR {} {} {}",
            message, throwable, context);
    }
}
```

### 2. ç³»ç»Ÿç›‘æ§

#### 2.1 å¥åº·æ£€æŸ¥

**å¥åº·æ£€æŸ¥é…ç½®**:

```java
@Component
public class CustomHealthIndicator implements HealthIndicator {
    
    @Autowired
    private DatabaseHealthChecker databaseHealthChecker;
    
    @Autowired
    private RedisHealthChecker redisHealthChecker;
    
    @Autowired
    private ExternalServiceHealthChecker externalServiceHealthChecker;
    
    @Override
    public Health health() {
        Health.Builder builder = new Health.Builder();
        
        // æ£€æŸ¥æ•°æ®åº“å¥åº·çŠ¶æ€
        Health databaseHealth = databaseHealthChecker.check();
        builder.withDetail("database", databaseHealth);
        
        // æ£€æŸ¥Rediså¥åº·çŠ¶æ€
        Health redisHealth = redisHealthChecker.check();
        builder.withDetail("redis", redisHealth);
        
        // æ£€æŸ¥å¤–éƒ¨æœåŠ¡å¥åº·çŠ¶æ€
        Health externalServiceHealth = externalServiceHealthChecker.check();
        builder.withDetail("externalService", externalServiceHealth);
        
        // ç»¼åˆå¥åº·çŠ¶æ€
        if (databaseHealth.getStatus() == Status.UP && 
            redisHealth.getStatus() == Status.UP) {
            builder.up();
        } else {
            builder.down();
        }
        
        return builder.build();
    }
}

@Component
public class DatabaseHealthChecker {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    public Health check() {
        try {
            jdbcTemplate.queryForObject("SELECT 1", Integer.class);
            return Health.up().withDetail("status", "Database connection is healthy").build();
        } catch (Exception e) {
            return Health.down()
                .withDetail("status", "Database connection failed")
                .withDetail("error", e.getMessage())
                .build();
        }
    }
}
```

#### 2.2 æŒ‡æ ‡ç›‘æ§

**è‡ªå®šä¹‰æŒ‡æ ‡**:

```java
@Component
public class BusinessMetrics {
    
    private final Counter userRegistrationCounter;
    private final Counter documentCreationCounter;
    private final Timer documentProcessingTimer;
    private final Gauge activeUsersGauge;
    
    public BusinessMetrics(MeterRegistry meterRegistry) {
        this.userRegistrationCounter = Counter.builder("business.user.registrations")
            .description("Number of user registrations")
            .register(meterRegistry);
        
        this.documentCreationCounter = Counter.builder("business.document.creations")
            .description("Number of document creations")
            .register(meterRegistry);
        
        this.documentProcessingTimer = Timer.builder("business.document.processing.time")
            .description("Time taken to process documents")
            .register(meterRegistry);
        
        this.activeUsersGauge = Gauge.builder("business.users.active")
            .description("Number of active users")
            .register(meterRegistry, this, BusinessMetrics::getActiveUserCount);
    }
    
    public void incrementUserRegistration() {
        userRegistrationCounter.increment();
    }
    
    public void incrementDocumentCreation() {
        documentCreationCounter.increment();
    }
    
    public Timer.Sample startDocumentProcessing() {
        return Timer.start();
    }
    
    public void recordDocumentProcessingTime(Timer.Sample sample) {
        sample.stop(documentProcessingTimer);
    }
    
    private double getActiveUserCount() {
        // å®ç°è·å–æ´»è·ƒç”¨æˆ·æ•°çš„é€»è¾‘
        return 0.0;
    }
}
```

## ğŸ“ˆ å¯æ‰©å±•æ€§è®¾è®¡

### 1. æ°´å¹³æ‰©å±•æ¶æ„

#### 1.1 æ— çŠ¶æ€è®¾è®¡

**æ— çŠ¶æ€æœåŠ¡å®ç°**:

```java
@RestController
public class UserController {
    
    // é¿å…åœ¨Controllerä¸­ä¿å­˜çŠ¶æ€
    // æ‰€æœ‰çŠ¶æ€éƒ½åº”è¯¥å­˜å‚¨åœ¨å¤–éƒ¨ç³»ç»Ÿä¸­ï¼ˆæ•°æ®åº“ã€ç¼“å­˜ç­‰ï¼‰
    
    @Autowired
    private UserService userService;
    
    @GetMapping("/users/{id}")
    public ResponseEntity<UserDTO> getUser(@PathVariable Long id) {
        UserDTO user = userService.getUserById(id);
        return ResponseEntity.ok(user);
    }
}

@Service
public class UserServiceImpl implements UserService {
    
    // ä½¿ç”¨å¤–éƒ¨ç¼“å­˜è€Œä¸æ˜¯æœ¬åœ°ç¼“å­˜
    @Autowired
    private CacheManager cacheManager;
    
    @Override
    public UserDTO getUserById(Long id) {
        // ä»åˆ†å¸ƒå¼ç¼“å­˜è·å–
        Cache cache = cacheManager.getCache("users");
        UserDTO user = cache.get(id, UserDTO.class);
        
        if (user == null) {
            // ä»æ•°æ®åº“åŠ è½½
            user = loadUserFromDatabase(id);
            // å­˜å‚¨åˆ°åˆ†å¸ƒå¼ç¼“å­˜
            cache.put(id, user);
        }
        
        return user;
    }
}
```

#### 1.2 è´Ÿè½½å‡è¡¡

**è´Ÿè½½å‡è¡¡é…ç½®**:

```yaml
# nginx.conf
upstream Junmo Platform_backend {
    least_conn;
    server backend1:8080 weight=1 max_fails=3 fail_timeout=30s;
    server backend2:8080 weight=1 max_fails=3 fail_timeout=30s;
    server backend3:8080 weight=1 max_fails=3 fail_timeout=30s;
}

server {
    listen 80;
    server_name Junmo Platform.example.com;
    
    location / {
        proxy_pass http://Junmo Platform_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # å¥åº·æ£€æŸ¥
        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;
        proxy_connect_timeout 5s;
        proxy_send_timeout 10s;
        proxy_read_timeout 10s;
    }
    
    # é™æ€èµ„æºç›´æ¥ç”±nginxæä¾›
    location /static/ {
        root /var/www/Junmo Platform;
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}
```

### 2. æ•°æ®åº“æ‰©å±•

#### 2.1 è¯»å†™åˆ†ç¦»

**è¯»å†™åˆ†ç¦»é…ç½®**:

```java
@Configuration
public class DataSourceConfig {
    
    @Bean
    @Primary
    public DataSource masterDataSource() {
        return DataSourceBuilder.create()
            .url("jdbc:mysql://mysql-master:3306/Junmo Platform")
            .username("Junmo Platform")
            .password("password")
            .driverClassName("com.mysql.cj.jdbc.Driver")
            .build();
    }
    
    @Bean
    public DataSource slaveDataSource() {
        return DataSourceBuilder.create()
            .url("jdbc:mysql://mysql-slave:3306/Junmo Platform")
            .username("Junmo Platform")
            .password("password")
            .driverClassName("com.mysql.cj.jdbc.Driver")
            .build();
    }
    
    @Bean
    public DataSource routingDataSource() {
        RoutingDataSource routingDataSource = new RoutingDataSource();
        Map<Object, Object> dataSourceMap = new HashMap<>();
        dataSourceMap.put("master", masterDataSource());
        dataSourceMap.put("slave", slaveDataSource());
        routingDataSource.setTargetDataSources(dataSourceMap);
        routingDataSource.setDefaultTargetDataSource(masterDataSource());
        return routingDataSource;
    }
}

// è¯»å†™åˆ†ç¦»æ³¨è§£
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface ReadOnly {
}

// è¯»å†™åˆ†ç¦»AOP
@Aspect
@Component
public class ReadOnlyInterceptor {
    
    @Autowired
    private DataSourceRouting dataSourceRouting;
    
    @Before("@annotation(readOnly)")
    public void setReadDataSource(ReadOnly readOnly) {
        dataSourceRouting.setDataSource("slave");
    }
    
    @After("@annotation(readOnly)")
    public void clearDataSource() {
        dataSourceRouting.clearDataSource();
    }
}
```

#### 2.2 åˆ†åº“åˆ†è¡¨

**åˆ†è¡¨ç­–ç•¥å®ç°**:

```java
@Component
public class ShardingStrategy {
    
    private static final int SHARD_COUNT = 4;
    
    /**
     * æ ¹æ®ç”¨æˆ·IDç¡®å®šåˆ†ç‰‡
     */
    public String determineShard(Long userId) {
        int shardIndex = (int) (userId % SHARD_COUNT);
        return "users_" + shardIndex;
    }
    
    /**
     * æ ¹æ®æ—¶é—´ç¡®å®šåˆ†è¡¨
     */
    public String determineTimeTable(LocalDateTime dateTime) {
        int year = dateTime.getYear();
        int month = dateTime.getMonthValue();
        return String.format("documents_%d%02d", year, month);
    }
}

@Repository
public class ShardedUserRepository {
    
    @Autowired
    private ShardingStrategy shardingStrategy;
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    public User findById(Long userId) {
        String tableName = shardingStrategy.determineShard(userId);
        String sql = "SELECT * FROM " + tableName + " WHERE id = ?";
        
        return jdbcTemplate.queryForObject(sql, new Object[]{userId}, new UserRowMapper());
    }
    
    public void save(User user) {
        String tableName = shardingStrategy.determineShard(user.getId());
        String sql = "INSERT INTO " + tableName + " (username, email, password) VALUES (?, ?, ?)";
        
        jdbcTemplate.update(sql, user.getUsername(), user.getEmail(), user.getPassword());
    }
}
```

---

*æœ¬æ–‡æ¡£æä¾›äº†è¯¦ç»†çš„éåŠŸèƒ½æ€§è®¾è®¡ï¼ŒåŒ…æ‹¬æ€§èƒ½ä¼˜åŒ–ã€å®‰å…¨é˜²æŠ¤ã€å¯ç»´æŠ¤æ€§ä¿è¯å’Œå¯æ‰©å±•æ€§æ¶æ„çš„å…·ä½“å®ç°ï¼Œä¸ºå¼€å‘å›¢é˜Ÿæä¾›äº†å®Œæ•´çš„ç³»ç»Ÿè´¨é‡ä¿è¯æŒ‡å¯¼ã€‚*