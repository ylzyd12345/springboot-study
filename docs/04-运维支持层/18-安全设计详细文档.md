# Junmo Platform å®‰å…¨è®¾è®¡è¯¦ç»†æ–‡æ¡£

## ğŸ“‹ æ–‡æ¡£ä¿¡æ¯

| é¡¹ç›® | å†…å®¹ |
|------|------|
| **æ–‡æ¡£åç§°** | Junmo Platform å®‰å…¨è®¾è®¡è¯¦ç»†æ–‡æ¡£ |
| **ç‰ˆæœ¬å·** | v1.0.0 |
| **åˆ›å»ºæ—¥æœŸ** | 2025-12-24 |
| **ä½œè€…** | å®‰å…¨æ¶æ„å¸ˆ |
| **å®¡æ ¸äºº** | é¦–å¸­å®‰å…¨å®˜ |
| **æ‰¹å‡†äºº** | æŠ€æœ¯æ€»ç›‘ |

## ğŸ¯ å®‰å…¨æ¶æ„æ€»è§ˆ

### å®‰å…¨è®¾è®¡åŸåˆ™

#### 1. çºµæ·±é˜²å¾¡åŸåˆ™
- **å¤šå±‚é˜²æŠ¤**: åœ¨ç½‘ç»œã€åº”ç”¨ã€æ•°æ®å¤šä¸ªå±‚é¢å»ºç«‹å®‰å…¨é˜²æŠ¤
- **å†—ä½™ä¿æŠ¤**: å…³é”®å®‰å…¨æœºåˆ¶å…·æœ‰å¤šé‡å¤‡ä»½
- **æ•…éšœå®‰å…¨**: ç³»ç»Ÿæ•…éšœæ—¶è‡ªåŠ¨è¿›å…¥å®‰å…¨çŠ¶æ€

#### 2. æœ€å°æƒé™åŸåˆ™
- **æƒé™æœ€å°åŒ–**: ç”¨æˆ·å’Œç³»ç»Ÿåªè·å¾—å®Œæˆä»»åŠ¡æ‰€éœ€çš„æœ€å°æƒé™
- **èŒè´£åˆ†ç¦»**: å…³é”®æ“ä½œéœ€è¦å¤šè§’è‰²åä½œå®Œæˆ
- **ä¸´æ—¶æˆæƒ**: ç‰¹æ®Šæƒé™å…·æœ‰æ—¶æ•ˆæ€§é™åˆ¶

#### 3. é›¶ä¿¡ä»»åŸåˆ™
- **æ°¸ä¸ä¿¡ä»»**: å¯¹æ‰€æœ‰è®¿é—®è¯·æ±‚éƒ½è¿›è¡Œèº«ä»½éªŒè¯
- **æŒç»­éªŒè¯**: åœ¨è®¿é—®è¿‡ç¨‹ä¸­æŒç»­éªŒè¯èº«ä»½å’Œæƒé™
- **æœ€å°æš´éœ²**: æœ€å°åŒ–ç³»ç»Ÿæš´éœ²é¢

### å®‰å…¨æ¶æ„æ¨¡å‹

```mermaid
graph TB
    subgraph "ç½‘ç»œå®‰å…¨å±‚"
        A1[é˜²ç«å¢™] --> A2[WAF]
        A2 --> A3[DDoSé˜²æŠ¤]
        A3 --> A4[è´Ÿè½½å‡è¡¡]
    end
    
    subgraph "æ¥å…¥å®‰å…¨å±‚"
        B1[APIç½‘å…³] --> B2[è®¤è¯æœåŠ¡]
        B2 --> B3[æˆæƒæœåŠ¡]
        B3 --> B4[é™æµç†”æ–­]
    end
    
    subgraph "åº”ç”¨å®‰å…¨å±‚"
        C1[è¾“å…¥éªŒè¯] --> C2[è¾“å‡ºç¼–ç ]
        C2 --> C3[ä¼šè¯ç®¡ç†]
        C3 --> C4[CORSé…ç½®]
    end
    
    subgraph "æ•°æ®å®‰å…¨å±‚"
        D1[æ•°æ®åŠ å¯†] --> D2[å¯†é’¥ç®¡ç†]
        D2 --> D3[æ•°æ®è„±æ•]
        D3 --> D4[å¤‡ä»½åŠ å¯†]
    end
    
    subgraph "ç›‘æ§å®¡è®¡å±‚"
        E1[å®‰å…¨ç›‘æ§] --> E2[æ—¥å¿—å®¡è®¡]
        E2 --> E3[å¼‚å¸¸æ£€æµ‹]
        E3 --> E4[å¨èƒæƒ…æŠ¥]
    end
    
    A1 --> B1
    B1 --> C1
    C1 --> D1
    D1 --> E1
```

## ğŸ” èº«ä»½è®¤è¯ä¸æˆæƒ

### è®¤è¯æ¶æ„è®¾è®¡

#### å¤šå› ç´ è®¤è¯ (MFA)
```java
@Configuration
public class MfaSaTokenConfig {
    
    @Bean
    public SaTokenInterceptor saTokenInterceptor() {
        return new SaTokenInterceptor();
    }
    
    @Bean
    public MfaFilter mfaFilter() {
        return new MfaFilter();
    }
}

@Component
public class MfaFilter implements Filter {
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) 
            throws IOException, ServletException {
        
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        HttpServletResponse httpResponse = (HttpServletResponse) response;
        
        String requestURI = httpRequest.getRequestURI();
        
        // MFA ç›¸å…³æ¥å£æ”¾è¡Œ
        if (requestURI.startsWith("/api/auth/mfa/")) {
            chain.doFilter(request, response);
            return;
        }
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦ MFA éªŒè¯
        if (requiresMfaVerification(httpRequest)) {
            if (!verifyMfa(httpRequest)) {
                httpResponse.setStatus(HttpStatus.UNAUTHORIZED.value());
                httpResponse.getWriter().write("MFA verification required");
                return;
            }
        }
        
        chain.doFilter(request, response);
    }
}

@Service
public class MfaService {
    
    @Autowired
    private TotpService totpService;
    
    @Autowired
    private SmsService smsService;
    
    public boolean verifyMfa(String username, String code, MfaType type) {
        switch (type) {
            case TOTP:
                return totpService.verifyCode(username, code);
            case SMS:
                return smsService.verifyCode(username, code);
            case EMAIL:
                return emailService.verifyCode(username, code);
            default:
                return false;
        }
    }
    
    public void generateMfaSecret(String username) {
        String secret = totpService.generateSecret();
        userService.saveMfaSecret(username, secret);
        
        // ç”ŸæˆäºŒç»´ç ä¾›ç”¨æˆ·æ‰«æ
        String qrCode = totpService.generateQrCode(username, secret);
        notificationService.sendMfaSetupEmail(username, qrCode);
    }
}
```

#### OAuth2/OIDC é›†æˆ
```java
@Configuration
public class OAuth2SaTokenConfig {
    
    @Bean
    public SaOAuth2Template saOAuth2Template() {
        return new SaOAuth2Template();
    }
    
    @Bean
    public SaOAuth2LoginHandler saOAuth2LoginHandler() {
        return new SaOAuth2LoginHandler();
    }
}

@Component
public class SaOAuth2Template extends SaOAuth2Template {
    
    @Override
    public SaClientModel getClientModel(String clientId) {
        // ä»æ•°æ®åº“è·å–å®¢æˆ·ç«¯é…ç½®
        return new SaClientModel()
                .setClientId(clientId)
                .setClientSecret("your-client-secret")
                .setAllowUrl("*")
                .setContractScope("openid")
                .setIsAutoMode(true);
    }
    
    @Override
    public String getRedirectUrl() {
        // è·å–å›è°ƒåœ°å€
        return "http://your-domain.com/api/auth/oauth2/callback";
    }
}

@Service
public class CustomOAuth2UserService implements OAuth2UserService<OAuth2UserRequest, OAuth2User> {
    
    @Override
    public OAuth2User loadUser(OAuth2UserRequest userRequest) throws OAuth2AuthenticationException {
        OAuth2User oauth2User = delegate.loadUser(userRequest);
        
        // å¤„ç†ç”¨æˆ·ä¿¡æ¯
        String email = oauth2User.getAttribute("email");
        String name = oauth2User.getAttribute("name");
        
        // åˆ›å»ºæˆ–æ›´æ–°æœ¬åœ°ç”¨æˆ·
        User user = userService.findOrCreateUser(email, name);
        
        return new CustomOAuth2User(user, oauth2User.getAttributes());
    }
}
```

### æˆæƒæ¶æ„è®¾è®¡

#### RBACæƒé™æ¨¡å‹
```java
@Entity
@Table(name = "roles")
public class Role {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(unique = true, nullable = false)
    private String name;
    
    private String description;
    
    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
        name = "role_permissions",
        joinColumns = @JoinColumn(name = "role_id"),
        inverseJoinColumns = @JoinColumn(name = "permission_id")
    )
    private Set<Permission> permissions = new HashSet<>();
}

@Component
public class StpInterfaceImpl implements StpInterface {
    
    @Autowired
    private UserMapper userMapper;
    
    @Override
    public List<String> getPermissionList(Object loginId, String loginType) {
        User user = userMapper.selectById((Long) loginId);
        if (user == null) {
            return Collections.emptyList();
        }
        
        // è·å–ç”¨æˆ·æƒé™åˆ—è¡¨
        return user.getRoles().stream()
                .flatMap(role -> role.getPermissions().stream())
                .map(Permission::getName)
                .distinct()
                .collect(Collectors.toList());
    }
    
    @Override
    public List<String> getRoleList(Object loginId, String loginType) {
        User user = userMapper.selectById((Long) loginId);
        if (user == null) {
            return Collections.emptyList();
        }
        
        // è·å–ç”¨æˆ·è§’è‰²åˆ—è¡¨
        return user.getRoles().stream()
                .map(Role::getName)
                .distinct()
                .collect(Collectors.toList());
    }
}

@Entity
@Table(name = "permissions")
public class Permission {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(unique = true, nullable = false)
    private String name;
    
    private String resource;
    
    private String action;
    
    // getters and setters
}

@Service
public class PermissionService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private RoleRepository roleRepository;
    
    public boolean hasPermission(String username, String resource, String action) {
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -> new UserNotFoundException(username));
        
        return user.getRoles().stream()
            .flatMap(role -> role.getPermissions().stream())
            .anyMatch(permission -> 
                permission.getResource().equals(resource) && 
                permission.getAction().equals(action)
            );
    }
    
    public Set<Permission> getUserPermissions(String username) {
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -> new UserNotFoundException(username));
        
        return user.getRoles().stream()
            .flatMap(role -> role.getPermissions().stream())
            .collect(Collectors.toSet());
    }
}
```

#### ABACå±æ€§æƒé™
```java
@Component
public class AbacPolicyEngine {
    
    @Autowired
    private PolicyRepository policyRepository;
    
    public boolean evaluate(String username, String resource, String action, Map<String, Object> context) {
        User user = userService.getUserByUsername(username);
        
        List<Policy> applicablePolicies = policyRepository.findApplicablePolicies(resource, action);
        
        for (Policy policy : applicablePolicies) {
            if (evaluatePolicy(policy, user, context)) {
                return policy.isEffect();
            }
        }
        
        return false; // é»˜è®¤æ‹’ç»
    }
    
    private boolean evaluatePolicy(Policy policy, User user, Map<String, Object> context) {
        // è¯„ä¼°ç­–ç•¥æ¡ä»¶
        for (Condition condition : policy.getConditions()) {
            if (!evaluateCondition(condition, user, context)) {
                return false;
            }
        }
        return true;
    }
}

@Entity
@Table(name = "policies")
public class Policy {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    
    private String resource;
    
    private String action;
    
    private boolean effect; // true=å…è®¸, false=æ‹’ç»
    
    @ElementCollection
    @CollectionTable(name = "policy_conditions")
    private List<Condition> conditions = new ArrayList<>();
}

@Embeddable
public class Condition {
    
    private String attribute;
    
    private String operator; // eq, ne, gt, lt, in, contains
    
    private String value;
}
```

## ğŸ”’ æ•°æ®å®‰å…¨è®¾è®¡

### æ•°æ®åŠ å¯†ç­–ç•¥

#### ä¼ è¾“åŠ å¯†
```java
@Configuration
public class EncryptionConfig {
    
    @Bean
    public RestTemplate secureRestTemplate() {
        RestTemplate restTemplate = new RestTemplate();
        
        // é…ç½®SSL
        SSLContext sslContext = SSLContextBuilder.create()
            .loadTrustMaterial((chain, authType) -> true) // ç”Ÿäº§ç¯å¢ƒéœ€è¦éªŒè¯è¯ä¹¦
            .build();
        
        HttpClient client = HttpClients.custom()
            .setSSLContext(sslContext)
            .build();
        
        HttpComponentsClientHttpRequestFactory factory = 
            new HttpComponentsClientHttpRequestFactory(client);
        restTemplate.setRequestFactory(factory);
        
        return restTemplate;
    }
}

@Configuration
public class WebSecurityConfig {
    
    @Bean
    public ServletWebServerFactory servletContainer() {
        TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();
        factory.addConnectorCustomizers(connector -> {
            connector.setProperty("sslProtocol", "TLS");
            connector.setProperty("sslEnabledProtocols", "TLSv1.2,TLSv1.3");
            connector.setProperty("ciphers", "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256");
        });
        return factory;
    }
}
```

#### å­˜å‚¨åŠ å¯†
```java
@Component
public class DataEncryptionService {
    
    @Value("${encryption.key}")
    private String encryptionKey;
    
    private final AESUtil aesUtil;
    
    public DataEncryptionService() {
        this.aesUtil = new AESUtil();
    }
    
    @EventListener
    public void handleUserCreated(UserCreatedEvent event) {
        // åŠ å¯†æ•æ„Ÿæ•°æ®
        User user = userRepository.findById(event.getUserId()).orElse(null);
        if (user != null) {
            encryptSensitiveData(user);
            userRepository.save(user);
        }
    }
    
    private void encryptSensitiveData(User user) {
        if (user.getPhone() != null) {
            user.setPhone(aesUtil.encrypt(user.getPhone(), encryptionKey));
        }
        if (user.getIdCard() != null) {
            user.setIdCard(aesUtil.encrypt(user.getIdCard(), encryptionKey));
        }
    }
    
    public String decryptPhone(String encryptedPhone) {
        return aesUtil.decrypt(encryptedPhone, encryptionKey);
    }
    
    public String encryptPhone(String phone) {
        return aesUtil.encrypt(phone, encryptionKey);
    }
}

public class AESUtil {
    
    private static final String ALGORITHM = "AES";
    private static final String TRANSFORMATION = "AES/CBC/PKCS5Padding";
    
    public String encrypt(String data, String key) throws Exception {
        SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(), ALGORITHM);
        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        cipher.init(Cipher.ENCRYPT_MODE, secretKey);
        
        byte[] encrypted = cipher.doFinal(data.getBytes());
        return Base64.getEncoder().encodeToString(encrypted);
    }
    
    public String decrypt(String encryptedData, String key) throws Exception {
        SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(), ALGORITHM);
        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        cipher.init(Cipher.DECRYPT_MODE, secretKey);
        
        byte[] decoded = Base64.getDecoder().decode(encryptedData);
        byte[] decrypted = cipher.doFinal(decoded);
        return new String(decrypted);
    }
}
```

### å¯†é’¥ç®¡ç†

#### å¯†é’¥è½®æ¢æœºåˆ¶
```java
@Service
public class KeyRotationService {
    
    @Autowired
    private KeyRepository keyRepository;
    
    @Scheduled(cron = "0 0 2 1 * ?") // æ¯æœˆ1å·å‡Œæ™¨2ç‚¹æ‰§è¡Œ
    public void rotateKeys() {
        log.info("Starting key rotation process");
        
        // ç”Ÿæˆæ–°å¯†é’¥
        String newKey = generateNewKey();
        
        // ä¿å­˜æ–°å¯†é’¥
        KeyInfo keyInfo = new KeyInfo();
        keyInfo.setKeyValue(newKey);
        keyInfo.setKeyType("AES");
        keyInfo.setCreatedAt(LocalDateTime.now());
        keyInfo.setStatus(KeyStatus.ACTIVE);
        
        keyRepository.save(keyInfo);
        
        // æ ‡è®°æ—§å¯†é’¥ä¸ºè¿‡æœŸ
        markOldKeysAsExpired();
        
        // é‡æ–°åŠ å¯†æ•°æ®
        reencryptDataWithNewKey(newKey);
        
        log.info("Key rotation completed successfully");
    }
    
    private String generateNewKey() {
        try {
            KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
            keyGenerator.init(256);
            SecretKey secretKey = keyGenerator.generateKey();
            return Base64.getEncoder().encodeToString(secretKey.getEncoded());
        } catch (Exception e) {
            throw new RuntimeException("Failed to generate new key", e);
        }
    }
    
    private void reencryptDataWithNewKey(String newKey) {
        // åˆ†æ‰¹å¤„ç†æ•°æ®
        int batchSize = 100;
        int offset = 0;
        
        List<User> users;
        do {
            users = userRepository.findBatchForReencryption(batchSize, offset);
            
            for (User user : users) {
                // ç”¨æ—§å¯†é’¥è§£å¯†
                String decryptedPhone = decryptWithCurrentKey(user.getPhone());
                // ç”¨æ–°å¯†é’¥åŠ å¯†
                String encryptedPhone = encryptWithKey(decryptedPhone, newKey);
                user.setPhone(encryptedPhone);
                
                userRepository.save(user);
            }
            
            offset += batchSize;
        } while (users.size() == batchSize);
    }
}
```

### æ•°æ®è„±æ•

#### æ•æ„Ÿæ•°æ®å¤„ç†
```java
@Component
public class DataMaskingService {
    
    public UserDTO maskSensitiveData(UserDTO user) {
        UserDTO maskedUser = new UserDTO();
        BeanUtils.copyProperties(user, maskedUser);
        
        // è„±æ•æ‰‹æœºå·
        if (maskedUser.getPhone() != null) {
            maskedUser.setPhone(maskPhone(maskedUser.getPhone()));
        }
        
        // è„±æ•é‚®ç®±
        if (maskedUser.getEmail() != null) {
            maskedUser.setEmail(maskEmail(maskedUser.getEmail()));
        }
        
        // è„±æ•èº«ä»½è¯
        if (maskedUser.getIdCard() != null) {
            maskedUser.setIdCard(maskIdCard(maskedUser.getIdCard()));
        }
        
        return maskedUser;
    }
    
    private String maskPhone(String phone) {
        if (phone == null || phone.length() < 7) {
            return phone;
        }
        return phone.substring(0, 3) + "****" + phone.substring(7);
    }
    
    private String maskEmail(String email) {
        if (email == null || !email.contains("@")) {
            return email;
        }
        String[] parts = email.split("@");
        String username = parts[0];
        String domain = parts[1];
        
        if (username.length() <= 2) {
            return username + "***@" + domain;
        }
        
        return username.substring(0, 2) + "***@" + domain;
    }
    
    private String maskIdCard(String idCard) {
        if (idCard == null || idCard.length() < 8) {
            return idCard;
        }
        return idCard.substring(0, 4) + "**********" + idCard.substring(idCard.length() - 4);
    }
}
```

## ğŸ›¡ï¸ åº”ç”¨å®‰å…¨è®¾è®¡

### è¾“å…¥éªŒè¯ä¸è¾“å‡ºç¼–ç 

#### é˜²æ­¢æ³¨å…¥æ”»å‡»
```java
@Component
public class InputValidationService {
    
    @Autowired
    private Validator validator;
    
    public void validateInput(Object input) {
        Set<ConstraintViolation<Object>> violations = validator.validate(input);
        if (!violations.isEmpty()) {
            throw new ConstraintViolationException(violations);
        }
    }
    
    public String sanitizeHtml(String input) {
        if (input == null) {
            return null;
        }
        
        // ä½¿ç”¨OWASP Java HTML Sanitizer
        PolicyFactory policy = new HtmlPolicyBuilder()
            .allowElements("b", "i", "u", "em", "strong", "p", "br")
            .allowAttributes("class").onElements("p")
            .toFactory();
        
        return policy.sanitize(input);
    }
    
    public String preventSqlInjection(String input) {
        if (input == null) {
            return null;
        }
        
        // ç§»é™¤æ½œåœ¨çš„SQLæ³¨å…¥å­—ç¬¦
        return input.replaceAll("[';\"\\\\]", "");
    }
}

@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @Autowired
    private InputValidationService validationService;
    
    @PostMapping
    public ResponseEntity<UserDTO> createUser(@Valid @RequestBody CreateUserRequest request) {
        // é¢å¤–çš„ä¸šåŠ¡å±‚éªŒè¯
        validationService.validateInput(request);
        
        // é˜²æ­¢XSSæ”»å‡»
        if (request.getBio() != null) {
            request.setBio(validationService.sanitizeHtml(request.getBio()));
        }
        
        UserDTO user = userService.createUser(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(user);
    }
}
```

#### è¾“å‡ºç¼–ç 
```java
@Component
public class OutputEncodingService {
    
    public String encodeForHtml(String input) {
        if (input == null) {
            return null;
        }
        
        return input.replace("&", "&amp;")
                   .replace("<", "&lt;")
                   .replace(">", "&gt;")
                   .replace("\"", "&quot;")
                   .replace("'", "&#x27;");
    }
    
    public String encodeForJavaScript(String input) {
        if (input == null) {
            return null;
        }
        
        return input.replace("\\", "\\\\")
                   .replace("\"", "\\\"")
                   .replace("'", "\\'")
                   .replace("\n", "\\n")
                   .replace("\r", "\\r")
                   .replace("\t", "\\t");
    }
    
    public String encodeForUrl(String input) {
        try {
            return URLEncoder.encode(input, StandardCharsets.UTF_8.name());
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException("Failed to encode URL", e);
        }
    }
}
```

### ä¼šè¯ç®¡ç†

#### å®‰å…¨ä¼šè¯é…ç½®
```java
@Configuration
public class SessionConfig {
    
    @Bean
    public HttpSessionEventPublisher httpSessionEventPublisher() {
        return new HttpSessionEventPublisher();
    }
    
    @Bean
    public CookieSerializer cookieSerializer() {
        DefaultCookieSerializer serializer = new DefaultCookieSerializer();
        serializer.setCookieName("SESSION");
        serializer.setCookiePath("/");
        serializer.setDomainNamePattern("^.+?\\.(\\w+\\.[a-z]+)$");
        serializer.setUseHttpOnlyCookie(true);
        serializer.setSameSite("Lax");
        return serializer;
    }
}

@Service
public class SessionService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private static final String SESSION_PREFIX = "spring:session:";
    
    public void createSession(String sessionId, User user) {
        SessionInfo sessionInfo = new SessionInfo();
        sessionInfo.setUserId(user.getId());
        sessionInfo.setUsername(user.getUsername());
        sessionInfo.setRoles(user.getRoles().stream().map(Role::getName).collect(Collectors.toSet()));
        sessionInfo.setCreatedAt(LocalDateTime.now());
        sessionInfo.setLastAccessedAt(LocalDateTime.now());
        sessionInfo.setIpAddress(getCurrentIpAddress());
        sessionInfo.setUserAgent(getCurrentUserAgent());
        
        redisTemplate.opsForValue().set(
            SESSION_PREFIX + sessionId, 
            sessionInfo, 
            Duration.ofHours(24)
        );
    }
    
    public boolean validateSession(String sessionId) {
        SessionInfo sessionInfo = getSessionInfo(sessionId);
        if (sessionInfo == null) {
            return false;
        }
        
        // æ£€æŸ¥ä¼šè¯æ˜¯å¦è¿‡æœŸ
        if (sessionInfo.getLastAccessedAt().plusHours(24).isBefore(LocalDateTime.now())) {
            invalidateSession(sessionId);
            return false;
        }
        
        // æ›´æ–°æœ€åè®¿é—®æ—¶é—´
        sessionInfo.setLastAccessedAt(LocalDateTime.now());
        redisTemplate.opsForValue().set(
            SESSION_PREFIX + sessionId, 
            sessionInfo, 
            Duration.ofHours(24)
        );
        
        return true;
    }
    
    public void invalidateSession(String sessionId) {
        redisTemplate.delete(SESSION_PREFIX + sessionId);
    }
    
    public void invalidateAllUserSessions(Long userId) {
        Set<String> keys = redisTemplate.keys(SESSION_PREFIX + "*");
        if (keys != null) {
            for (String key : keys) {
                SessionInfo sessionInfo = (SessionInfo) redisTemplate.opsForValue().get(key);
                if (sessionInfo != null && sessionInfo.getUserId().equals(userId)) {
                    redisTemplate.delete(key);
                }
            }
        }
    }
}
```

### CORSé…ç½®

#### è·¨åŸŸå®‰å…¨é…ç½®
```java
@Configuration
public class CorsConfig {
    
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        
        // åªå…è®¸ç‰¹å®šçš„æº
        configuration.setAllowedOriginPatterns(Arrays.asList(
            "https://admin.Junmo Platform.com",
            "https://app.Junmo Platform.com"
        ));
        
        // åªå…è®¸å¿…è¦çš„HTTPæ–¹æ³•
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        
        // åªå…è®¸å¿…è¦çš„å¤´éƒ¨
        configuration.setAllowedHeaders(Arrays.asList(
            "Authorization",
            "Content-Type",
            "X-Requested-With"
        ));
        
        // å…è®¸å‡­è¯
        configuration.setAllowCredentials(true);
        
        // é¢„æ£€è¯·æ±‚ç¼“å­˜æ—¶é—´
        configuration.setMaxAge(3600L);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/api/**", configuration);
        
        return source;
    }
}
```

## ğŸ” å®‰å…¨ç›‘æ§ä¸å®¡è®¡

### å®‰å…¨äº‹ä»¶ç›‘æ§

#### å¼‚å¸¸æ£€æµ‹
```java
@Component
public class SecurityMonitoringService {
    
    @Autowired
    private MeterRegistry meterRegistry;
    
    @Autowired
    private AlertService alertService;
    
    private final Map<String, AtomicInteger> attemptCounter = new ConcurrentHashMap<>();
    
    @EventListener
    public void handleAuthenticationFailure(AuthenticationFailureBadCredentialsEvent event) {
        String username = event.getAuthentication().getName();
        String ipAddress = getCurrentIpAddress();
        
        // è®°å½•å¤±è´¥æ¬¡æ•°
        String key = username + ":" + ipAddress;
        AtomicInteger counter = attemptCounter.computeIfAbsent(key, k -> new AtomicInteger(0));
        int attempts = counter.incrementAndGet();
        
        // è®°å½•æŒ‡æ ‡
        meterRegistry.counter("security.auth.failure", 
            "username", username, 
            "ip", ipAddress).increment();
        
        // æ£€æµ‹æš´åŠ›ç ´è§£
        if (attempts >= 5) {
            handleSuspiciousActivity(username, ipAddress, "Multiple authentication failures");
        }
    }
    
    @EventListener
    public void handleAuthorizationFailure(AccessDeniedEvent event) {
        Authentication auth = event.getAuthentication();
        String username = auth.getName();
        String ipAddress = getCurrentIpAddress();
        
        meterRegistry.counter("security.auth.denied",
            "username", username,
            "ip", ipAddress).increment();
        
        // æ£€æµ‹æƒé™æå‡å°è¯•
        if (isPrivilegeEscalationAttempt(event)) {
            handleSuspiciousActivity(username, ipAddress, "Potential privilege escalation");
        }
    }
    
    private void handleSuspiciousActivity(String username, String ipAddress, String reason) {
        // è®°å½•å®‰å…¨äº‹ä»¶
        SecurityEvent event = new SecurityEvent();
        event.setType(SecurityEventType.SUSPICIOUS_ACTIVITY);
        event.setUsername(username);
        event.setIpAddress(ipAddress);
        event.setDescription(reason);
        event.setTimestamp(LocalDateTime.now());
        
        securityEventRepository.save(event);
        
        // å‘é€å‘Šè­¦
        alertService.sendSecurityAlert(
            String.format("Suspicious activity detected: %s from %s - %s", 
                username, ipAddress, reason)
        );
        
        // å¯é€‰ï¼šä¸´æ—¶å°ç¦IP
        if (shouldBlockIp(ipAddress)) {
            blockIpAddress(ipAddress, Duration.ofMinutes(30));
        }
    }
}
```

### æ—¥å¿—å®¡è®¡

#### å®‰å…¨æ—¥å¿—è®°å½•
```java
@Component
public class SecurityAuditService {
    
    @Autowired
    private AuditLogRepository auditLogRepository;
    
    @EventListener
    @Async
    public void handleUserLogin(AuthenticationSuccessEvent event) {
        Authentication auth = event.getAuthentication();
        String username = auth.getName();
        String ipAddress = getCurrentIpAddress();
        
        AuditLog log = new AuditLog();
        log.setAction(AuditAction.USER_LOGIN);
       .setUsername(username);
        setAuditLogMetadata(log);
        log.setDetails(String.format("User logged in from IP: %s", ipAddress));
        
        auditLogRepository.save(log);
    }
    
    @EventListener
    @Async
    public void handleUserLogout(LogoutSuccessEvent event) {
        Authentication auth = event.getAuthentication();
        String username = auth.getName();
        
        AuditLog log = new AuditLog();
        log.setAction(AuditAction.USER_LOGOUT);
        setUsername(username);
        setAuditLogMetadata(log);
        log.setDetails("User logged out");
        
        auditLogRepository.save(log);
    }
    
    @EventListener
    @Async
    public void handleDataAccess(DataAccessEvent event) {
        AuditLog log = new AuditLog();
        log.setAction(AuditAction.DATA_ACCESS);
       .setUsername(event.getUsername());
        setAuditLogMetadata(log);
        log.setResourceType(event.getResourceType());
        log.setResourceId(event.getResourceId());
        log.setDetails(event.getDetails());
        
        auditLogRepository.save(log);
    }
    
    private void setAuditLogMetadata(AuditLog log) {
        log.setTimestamp(LocalDateTime.now());
        log.setIpAddress(getCurrentIpAddress());
        log.setUserAgent(getCurrentUserAgent());
        log.setSessionId(getCurrentSessionId());
    }
}

@Aspect
@Component
public class AuditAspect {
    
    @Autowired
    private SecurityAuditService auditService;
    
    @Around("@annotation(auditable)")
    public Object auditMethod(ProceedingJoinPoint joinPoint, Auditable auditable) throws Throwable {
        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();
        
        try {
            // è®°å½•æ–¹æ³•è°ƒç”¨
            auditService.recordMethodCall(methodName, args);
            
            // æ‰§è¡Œæ–¹æ³•
            Object result = joinPoint.proceed();
            
            // è®°å½•æˆåŠŸç»“æœ
            auditService.recordMethodSuccess(methodName, result);
            
            return result;
        } catch (Exception e) {
            // è®°å½•å¼‚å¸¸
            auditService.recordMethodException(methodName, e);
            throw e;
        }
    }
}
```

## ğŸš¨ å¨èƒæ£€æµ‹ä¸é˜²æŠ¤

### WAFé…ç½®

#### Webåº”ç”¨é˜²ç«å¢™
```yaml
# application.yaml
spring:
  security:
    waf:
      enabled: true
      rules:
        - name: "SQL Injection Protection"
          pattern: "(?i)(union|select|insert|update|delete|drop|create|alter|exec|execute)"
          action: "BLOCK"
          severity: "HIGH"
        - name: "XSS Protection"
          pattern: "(?i)(<script|javascript:|vbscript:|onload=|onerror=)"
          action: "BLOCK"
          severity: "HIGH"
        - name: "Path Traversal Protection"
          pattern: "(\\.{2}|%2e%2e|%c0%ae%c0%ae)"
          action: "BLOCK"
          severity: "MEDIUM"
        - name: "Command Injection Protection"
          pattern: "(;|\\||&|`|\\$|\\(\\))"
          action: "BLOCK"
          severity: "HIGH"
```

```java
@Component
public class WebApplicationFirewall {
    
    @Autowired
    private List<WafRule> wafRules;
    
    @Component
    @Order(Ordered.HIGHEST_PRECEDENCE)
    public class WafFilter implements Filter {
        
        @Override
        public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) 
                throws IOException, ServletException {
            
            HttpServletRequest httpRequest = (HttpServletRequest) request;
            HttpServletResponse httpResponse = (HttpServletResponse) response;
            
            if (isMaliciousRequest(httpRequest)) {
                httpResponse.setStatus(HttpStatus.FORBIDDEN.value());
                httpResponse.getWriter().write("Access denied by WAF");
                return;
            }
            
            chain.doFilter(request, response);
        }
        
        private boolean isMaliciousRequest(HttpServletRequest request) {
            String uri = request.getRequestURI();
            String queryString = request.getQueryString();
            String userAgent = request.getHeader("User-Agent");
            String clientIp = getClientIpAddress(request);
            
            // æ£€æŸ¥æ‰€æœ‰WAFè§„åˆ™
            for (WafRule rule : wafRules) {
                if (rule.matches(uri, queryString, userAgent, clientIp)) {
                    logSecurityEvent(rule, request);
                    return true;
                }
            }
            
            return false;
        }
    }
}

public interface WafRule {
    boolean matches(String uri, String queryString, String userAgent, String clientIp);
    String getName();
    String getAction();
    String getSeverity();
}

@Component
public class SqlInjectionRule implements WafRule {
    
    private static final Pattern SQL_INJECTION_PATTERN = 
        Pattern.compile("(?i)(union|select|insert|update|delete|drop|create|alter|exec|execute)");
    
    @Override
    public boolean matches(String uri, String queryString, String userAgent, String clientIp) {
        if (queryString != null && SQL_INJECTION_PATTERN.matcher(queryString).find()) {
            return true;
        }
        return false;
    }
    
    @Override
    public String getName() {
        return "SQL Injection Protection";
    }
    
    @Override
    public String getAction() {
        return "BLOCK";
    }
    
    @Override
    public String getSeverity() {
        return "HIGH";
    }
}
```

### DDoSé˜²æŠ¤

#### é™æµé˜²æŠ¤
```java
@Component
public class DdosProtectionService {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    private final Map<String, RateLimiter> rateLimiters = new ConcurrentHashMap<>();
    
    @PostConstruct
    public void init() {
        // åˆå§‹åŒ–ä¸åŒçº§åˆ«çš„é™æµå™¨
        rateLimiters.put("strict", RateLimiter.create(10));    // 10 requests/second
        rateLimiters.put("normal", RateLimiter.create(100));   // 100 requests/second
        rateLimiters.put("lenient", RateLimiter.create(1000)); // 1000 requests/second
    }
    
    public boolean checkRateLimit(String clientIp, String endpoint) {
        String key = "rate_limit:" + clientIp + ":" + endpoint;
        
        // ä½¿ç”¨æ»‘åŠ¨çª—å£ç®—æ³•
        long currentTime = System.currentTimeMillis();
        long windowStart = currentTime - 60000; // 1åˆ†é’Ÿçª—å£
        
        // æ¸…ç†è¿‡æœŸè®°å½•
        redisTemplate.opsForZSet().removeRangeByScore(key, 0, windowStart);
        
        // è·å–å½“å‰çª—å£å†…çš„è¯·æ±‚æ•°
        Long requestCount = redisTemplate.opsForZSet().count(key, windowStart, currentTime);
        
        // æ ¹æ®ç«¯ç‚¹ç±»å‹è®¾ç½®ä¸åŒçš„é™åˆ¶
        int limit = getRequestLimit(endpoint);
        
        if (requestCount >= limit) {
            // è®°å½•DDoSäº‹ä»¶
            recordDdosEvent(clientIp, endpoint, requestCount);
            return false;
        }
        
        // è®°å½•å½“å‰è¯·æ±‚
        redisTemplate.opsForZSet().add(key, UUID.randomUUID().toString(), currentTime);
        redisTemplate.expire(key, Duration.ofMinutes(1));
        
        return true;
    }
    
    private int getRequestLimit(String endpoint) {
        if (endpoint.startsWith("/api/auth/")) {
            return 10; // è®¤è¯æ¥å£é™åˆ¶æ›´ä¸¥æ ¼
        } else if (endpoint.startsWith("/api/admin/")) {
            return 50; // ç®¡ç†æ¥å£
        } else {
            return 100; // æ™®é€šæ¥å£
        }
    }
    
    private void recordDdosEvent(String clientIp, String endpoint, long requestCount) {
        SecurityEvent event = new SecurityEvent();
        event.setType(SecurityEventType.DDOS_ATTACK);
        event.setIpAddress(clientIp);
        event.setResourceType("API_ENDPOINT");
        event.setResourceId(endpoint);
        event.setDescription(String.format("DDoS attempt detected: %d requests to %s", requestCount, endpoint));
        event.setTimestamp(LocalDateTime.now());
        
        securityEventRepository.save(event);
        
        // å¯é€‰ï¼šä¸´æ—¶å°ç¦IP
        if (requestCount > getRequestLimit(endpoint) * 2) {
            blockIpAddress(clientIp, Duration.ofMinutes(15));
        }
    }
}
```

## ğŸ“‹ å®‰å…¨åˆè§„æ€§

### æ•°æ®ä¿æŠ¤åˆè§„

#### GDPRåˆè§„å®ç°
```java
@Service
public class GdprComplianceService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private AuditLogRepository auditLogRepository;
    
    @Transactional
    public UserDataExport exportUserData(String username) {
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -> new UserNotFoundException(username));
        
        UserDataExport export = new UserDataExport();
        export.setUserId(user.getId());
        export.setUsername(user.getUsername());
        export.setEmail(user.getEmail());
        export.setPhone(decryptPhone(user.getPhone()));
        export.setCreatedAt(user.getCreatedAt());
        export.setUpdatedAt(user.getUpdatedAt());
        
        // å¯¼å‡ºç”¨æˆ·æ´»åŠ¨æ—¥å¿—
        List<AuditLog> userLogs = auditLogRepository.findByUsername(username);
        export.setActivityLogs(userLogs);
        
        // è®°å½•æ•°æ®å¯¼å‡ºäº‹ä»¶
        recordDataExportEvent(username);
        
        return export;
    }
    
    @Transactional
    public void deleteUserData(String username) {
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -> new UserNotFoundException(username));
        
        // è½¯åˆ é™¤ç”¨æˆ·æ•°æ®
        user.setDeleted(true);
        user.setDeletedAt(LocalDateTime.now());
        user.setEmail("deleted-" + user.getId() + "@deleted.com");
        user.setPhone(null);
        user.setUsername("deleted-" + user.getId());
        
        userRepository.save(user);
        
        // è®°å½•æ•°æ®åˆ é™¤äº‹ä»¶
        recordDataDeletionEvent(username);
    }
    
    public boolean hasConsent(String username, ConsentType consentType) {
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -> new UserNotFoundException(username));
        
        return user.getConsents().stream()
            .anyMatch(consent -> 
                consent.getType() == consentType && 
                consent.isGranted() && 
                !consent.isExpired()
            );
    }
    
    @Transactional
    public void grantConsent(String username, ConsentType consentType, Duration validity) {
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -> new UserNotFoundException(username));
        
        Consent consent = new Consent();
        consent.setUser(user);
        consent.setType(consentType);
        consent.setGranted(true);
        consent.setGrantedAt(LocalDateTime.now());
        consent.setExpiresAt(LocalDateTime.now().plus(validity));
        
        user.getConsents().add(consent);
        userRepository.save(user);
        
        recordConsentEvent(username, consentType, true);
    }
}
```

### å®‰å…¨å®¡è®¡æŠ¥å‘Š

#### å®šæœŸå®‰å…¨è¯„ä¼°
```java
@Service
public class SecurityAuditService {
    
    @Scheduled(cron = "0 0 1 1 * ?") // æ¯æœˆ1å·å‡Œæ™¨1ç‚¹æ‰§è¡Œ
    public void generateMonthlySecurityReport() {
        SecurityReport report = new SecurityReport();
        report.setReportType(SecurityReportType.MONTHLY);
        report.setPeriod(getLastMonthPeriod());
        
        // æ”¶é›†å®‰å…¨æŒ‡æ ‡
        report.setAuthenticationMetrics(collectAuthenticationMetrics());
        report.setAuthorizationMetrics(collectAuthorizationMetrics());
        report.setVulnerabilityMetrics(collectVulnerabilityMetrics());
        report.setIncidentMetrics(collectIncidentMetrics());
        
        // ç”Ÿæˆå»ºè®®
        report.setRecommendations(generateSecurityRecommendations(report));
        
        // ä¿å­˜æŠ¥å‘Š
        securityReportRepository.save(report);
        
        // å‘é€æŠ¥å‘Šç»™å®‰å…¨å›¢é˜Ÿ
        emailService.sendSecurityReport(report);
    }
    
    private AuthenticationMetrics collectAuthenticationMetrics() {
        AuthenticationMetrics metrics = new AuthenticationMetrics();
        
        // ç»Ÿè®¡ç™»å½•æˆåŠŸ/å¤±è´¥æ¬¡æ•°
        long successfulLogins = auditLogRepository.countByActionAndTimestampBetween(
            AuditAction.USER_LOGIN, 
            getMonthStart(), 
            getMonthEnd()
        );
        
        long failedLogins = securityEventRepository.countByTypeAndTimestampBetween(
            SecurityEventType.AUTHENTICATION_FAILURE,
            getMonthStart(),
            getMonthEnd()
        );
        
        metrics.setSuccessfulLogins(successfulLogins);
        metrics.setFailedLogins(failedLogins);
        metrics.setSuccessRate(calculateSuccessRate(successfulLogins, failedLogins));
        
        // ç»Ÿè®¡MFAä½¿ç”¨ç‡
        long mfaLogins = auditLogRepository.countByActionAndDetailsContaining(
            AuditAction.USER_LOGIN, 
            "MFA"
        );
        metrics.setMfaUsageRate(calculateMfaUsageRate(mfaLogins, successfulLogins));
        
        return metrics;
    }
    
    private List<SecurityRecommendation> generateSecurityRecommendations(SecurityReport report) {
        List<SecurityRecommendation> recommendations = new ArrayList<>();
        
        // åŸºäºæŒ‡æ ‡ç”Ÿæˆå»ºè®®
        if (report.getAuthenticationMetrics().getSuccessRate() < 0.95) {
            recommendations.add(new SecurityRecommendation(
                "IMPROVE_AUTHENTICATION",
                "Authentication success rate is below 95%. Consider implementing additional security measures.",
                "HIGH"
            ));
        }
        
        if (report.getVulnerabilityMetrics().getHighVulnerabilities() > 0) {
            recommendations.add(new SecurityRecommendation(
                "FIX_VULNERABILITIES",
                "High severity vulnerabilities detected. Immediate remediation required.",
                "CRITICAL"
            ));
        }
        
        return recommendations;
    }
}
```

## ğŸ”§ å®‰å…¨é…ç½®æœ€ä½³å®è·µ

### ç”Ÿäº§ç¯å¢ƒå®‰å…¨é…ç½®

#### å®‰å…¨é…ç½®æ¸…å•
```yaml
# application-prod.yaml
spring:
  security:
    require-ssl: true
    headers:
      frame-options: DENY
      content-type-options: nosniff
      xss-protection: "1; mode=block"
      referrer-policy: strict-origin-when-cross-origin
      
server:
  ssl:
    enabled: true
    key-store: classpath:keystore.p12
    key-store-password: ${SSL_KEYSTORE_PASSWORD}
    key-store-type: PKCS12
    key-alias: Junmo Platform
    protocol: TLS
    enabled-protocols: TLSv1.2,TLSv1.3
    ciphers: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
    
  tomcat:
    remote-ip-header: X-Forwarded-For
    protocol-header: X-Forwarded-Proto
    
logging:
  level:
    org.springframework.security: DEBUG
    com.junmo.Junmo Platform.security: DEBUG
    
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
  endpoint:
    health:
      show-details: when-authorized
  security:
    enabled: true
```

### å®‰å…¨æµ‹è¯•

#### å®‰å…¨æµ‹è¯•ç”¨ä¾‹
```java
@SpringBootTest
@AutoConfigureMockMvc
public class SecurityTests {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Test
    public void testSqlInjectionProtection() throws Exception {
        String maliciousInput = "admin'; DROP TABLE users; --";
        
        mockMvc.perform(post("/api/users/login")
                .param("username", maliciousInput)
                .param("password", "password"))
                .andExpect(status().isBadRequest());
    }
    
    @Test
    public void testXssProtection() throws Exception {
        String xssPayload = "<script>alert('XSS')</script>";
        
        mockMvc.perform(post("/api/users")
                .contentType(MediaType.APPLICATION_JSON)
                .content("{\"username\":\"test\",\"bio\":\"" + xssPayload + "\"}"))
                .andExpect(status().isBadRequest());
    }
    
    @Test
    public void testAuthenticationRequired() throws Exception {
        mockMvc.perform(get("/api/users/profile"))
                .andExpect(status().isUnauthorized());
    }
    
    @Test
    public void testAuthorizationDenied() throws Exception {
        // æ™®é€šç”¨æˆ·å°è¯•è®¿é—®ç®¡ç†å‘˜æ¥å£
        String token = obtainUserToken("user", "password");
        
        mockMvc.perform(get("/api/admin/users")
                .header("Authorization", "Bearer " + token))
                .andExpect(status().isForbidden());
    }
    
    @Test
    public void testRateLimiting() throws Exception {
        // å¿«é€Ÿå‘é€å¤šä¸ªè¯·æ±‚æµ‹è¯•é™æµ
        for (int i = 0; i < 20; i++) {
            mockMvc.perform(post("/api/auth/login")
                    .param("username", "test")
                    .param("password", "wrong"));
        }
        
        mockMvc.perform(post("/api/auth/login")
                .param("username", "test")
                .param("password", "wrong"))
                .andExpect(status().isTooManyRequests());
    }
}
```

---

*æœ¬æ–‡æ¡£å°†éšç€å®‰å…¨å¨èƒç¯å¢ƒçš„å˜åŒ–æŒç»­æ›´æ–°ï¼Œç¡®ä¿ç³»ç»Ÿå®‰å…¨é˜²æŠ¤èƒ½åŠ›çš„æŒç»­æå‡ã€‚*